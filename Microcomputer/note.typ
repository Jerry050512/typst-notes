#import "../template/conf.typ": conf
#import "../template/components.typ": *

#import "@preview/codly:1.3.0": codly, codly-init
#import "@preview/codly-languages:0.1.8": codly-languages
#import "@preview/fletcher:0.5.8" as fletcher: diagram, node, edge

#show: codly-init
#codly(languages: codly-languages)

#show: conf.with(
  title: [
    微机原理
  ],
  authors: (
    (
      name: [Gang.],
      affiliation: [Hangzhou Dianzi University],
      email: "jerry050512@outlook.com",
    ),
  )
)

#set figure(numbering: none)

#show table: it => align(center, it)

#set table(
  fill: (x, y) => if y == 0 {luma(80%)},
  align: center+horizon,
)

= 课程介绍 & 微机概述

== 冯诺依曼结构

冯诺依曼计算机结构的主要特点是：程序和数据共同存放在同一个存储器中，CPU通过同一组总线（地址总线、数据总线、控制总线）来访问指令和数据。

#figure(
  diagram(
    spacing: 4em,
    {
      let tint(c) = (stroke: c, fill: rgb(..c.components().slice(0,3), 5%), inset: 8pt)
      node(enclose: ((0,0), (0,2)), box(stack(dir: ttb, spacing: 5pt, .."输入设备".split("")), width: 3em), ..tint(teal), name: <input>)  
      node(enclose: ((2,0), (2,2)), box(stack(dir: ttb, spacing: 5pt, .."输出设备".split("")), width: 3em), ..tint(teal), name: <output>)
      node((1, 0), "存储器", ..tint(blue), name: <storage>)
      node((1, 1), "运算器", ..tint(yellow), name: <alu>)
      node((1, 2), "控制器", ..tint(red), name: <cu>)
      node(enclose: ((1,1), (1, 2)), "CPU", ..tint(green), name: <cpu>)
    },

    edge((0, 0), <storage>, "==>", stroke: teal + .75pt),
    edge(<storage>, (2, 0), "==>", stroke: teal + .75pt),
    edge((0, 2), <cu>, "-|>", stroke: blue, shift: 1.5pt),
    edge(<cu>, (0, 2), "-|>", stroke: blue, shift: 1.5pt),
    edge((2, 2), <cu>, "-|>", stroke: blue, shift: 1.5pt),
    edge(<cu>, (2, 2), "-|>", stroke: blue, shift: 1.5pt),
    edge(<cu>, <alu>, "-|>", stroke: blue, shift: 1.5em),
    edge(<alu>, <cu>, "-|>", stroke: blue, shift: 1.5em),
    edge(<storage>, <alu>, "-|>", stroke: blue, shift: 1.5em),
    edge(<alu>, <storage>, "-|>", stroke: blue, shift: 1.5em),
    
    edge(<cu>, <storage>, "-|>", stroke: blue, bend: 30deg, shift: 10pt),
    edge(<storage>, <cu>, "-|>", stroke: blue, bend: 30deg, shift: 10pt),
  ), 
  caption: [冯诺依曼结构]
)

== 计算机分类

*区分* 
- 普林斯顿结构, 哈佛结构
- 指令体系: RISC (精简指令集计算机), CISC (复杂指令集计算机)。

注：MCS-51系列微控制器属于CISC类型。

#table(
  columns: 2,
  align: center,
  [*冯·诺依曼结构 (Von Neumann Architecture)*], [*哈佛结构 (Harvard Architecture)*],
  [也称普林斯顿结构 (Princeton Architecture)。其主要特点是程序指令和数据共同存放在同一个存储器中，通过同一组地址总线和数据总线进行访问。这意味着CPU在任一时刻只能读取指令或读写数据，不能同时进行。],
  [其主要特点是程序指令存储和数据存储在物理上是分开的，各自拥有独立的地址总线和数据总线。这使得CPU可以同时获取指令和存取数据，从而提高了执行效率和并行处理能力。目前绝大部分微控制器，包括MCS-51系列，都采用哈佛结构。]
)

= MCS-51微控制器内部核心组件

#figure(
    image("assets/8051.png", height: 40%),
    caption: [8051芯片示意图]
)

MCS-51微控制器是一款经典的8位微控制器，其内部集成了执行控制任务所需的多种核心功能部件。这些组件协同工作，为嵌入式应用提供了强大的支持。

- *中央处理器 (CPU)*: 8位，是微控制器的大脑，负责解释和执行指令，进行算术逻辑运算和数据处理。
- *程序存储器 (Program Memory - ROM/EPROM/Flash)*: 用于永久存放用户程序代码和固定常数。部分型号MCS-51内置ROM/EPROM (如经典的4KB或8KB容量)。现代衍生型号多采用Flash存储器，方便程序的多次擦写。
- *数据存储器 (Data Memory - RAM)*: 用于临时存放程序运行过程中的变量、中间结果以及堆栈信息。MCS-51通常内置128字节或256字节的RAM。
- *并行I/O口 (Parallel I/O Ports)*: 通常有4个8位并行I/O口 (`P0`, `P1`, `P2`, `P3`)，共32条I/O线。这些口线不仅可以作为通用的数字输入输出，许多还具有第二功能，例如：
    - `P0`口：分时复用为低8位地址总线 (`A0-A7`) 和数据总线 (`D0-D7`)。
    - `P2`口：作为高8位地址总线 (`A8-A15`) 或通用I/O口。
    - `P3`口：各引脚具有特殊功能，如外部中断输入 (#overline(`INT0`), #overline(`INT1`))、定时器外部输入 (`T0`, `T1`)、串行通信线 (`RXD`, `TXD`) 以及外部数据存储器的读写控制信号 (#overline(`RD`), #overline(`WR`))。
- *中断系统 (Interrupt System)*: 能够响应来自内部外设（如定时器溢出、串行口数据收发完成）或外部引脚的事件，暂停当前任务，转去执行特定的中断服务程序。标准MCS-51有5个中断源，支持两级中断优先级。
- *定时器/计数器 (Timers/Counters)*: 通常内置2个16位的定时器/计数器 (`T0`, `T1`)。它们既可以作为定时器，对内部机器周期计数以实现精确定时；也可以作为计数器，对外部引脚上的脉冲信号进行计数。常用于延时产生、波形生成、事件计数以及为串行通信提供波特率。
- *串行接口 (Serial Port - UART)*: 内置一个全双工的异步串行通信接口 (UART)，可以通过`RXD` (P3.0) 和`TXD` (P3.1) 引脚与PC、其他微控制器或串行设备进行数据交换。
- *布尔处理器 (Boolean Processor)*: 具有强大的位处理能力，能够对单个位进行置位、清零、取反、测试并转移等操作，非常适合于控制应用中的逻辑判断和位操作。
- *时钟电路 (Clock Circuitry)*: 内部集成时钟振荡器电路，用户只需外接石英晶体（晶振）和两个微调电容，即可为整个微控制器系统提供稳定和精确的时钟脉冲。
- *指令系统 (Instruction Set)*: MCS-51拥有一套包含111条指令的指令集（针对标准型号），这些指令功能丰富，支持多种寻址方式，使其能够高效地执行控制密集型任务。它属于复杂指令集计算机 (CISC - Complex Instruction Set Computer)。

== 控制器 (Control Unit)

控制器由 *操作控制部件、时序发生器、指令寄存器 IR、指令译码器 ID、指令计数器 PC* 等组成. \
它完成取指、译码和执行等全过程的控制. 

=== 指令计数器 `PC (Program Counter)`

- 一个 `16` 位按机器周期自动 `+1` 的计数器
- 总是指向下一条指令的首地址
- 分支、跳转、调用、中断、复位均会改变 `PC` 值
- 用户不可直接读写 `PC`
- 地址范围: `0000H ~ FFFFH`, 可寻址 `64K` 程序空间

=== 堆栈指针 `SP (Stack Pointer)`

- `8` 位寄存器, 位于内部 RAM 的低 128 字节中
- 栈的结构为 *先进后出 (LIFO) *
- 默认复位初值为 `07H`, 即从地址 `08H` 开始存放压栈数据
- 执行 `PUSH` 指令前先 `SP + 1`, 再写入数据；`POP` 则先读取数据, 再 `SP - 1`

=== 数据指针 `DPTR (Data Pointer)`

- 由 `DPH` (高 8 位) 与 `DPL` (低 8 位) 组成的 `16` 位寄存器
- 由用户控制, 常用于操作外部数据存储器或查表指令 (如 `MOVX`, `MOVC`) 
- 是 MCS-51 中较少的*用户可操作的 16 位地址寄存器*

=== 指令寄存器 `IR` 与指令译码器 `ID`

- `IR` 用于暂存当前获取的操作码
- `ID` 根据 `IR` 内容进行译码, 产生微操作控制信号

=== 时序发生器

- 配合振荡器产生的时钟脉冲, 控制 CPU 内部各阶段的操作节奏
- 提供*机器周期*与*状态周期*的划分基础

== 运算器

运算器负责 *数据的运算、处理与加工*, 是中央处理器的核心组成. \
由 *算术逻辑单元 ALU、累加器 ACC、暂存寄存器 TMP、程序状态字 PSW、布尔处理器、BCD 码调整电路* 等部分组成, 并通过 *内部总线* 实现相互连接. 

=== 累加器 `ACC (Accumulator)`

- 是 MCS-51 最常用的数据暂存与运算寄存器
- 绝大多数算术和逻辑运算都以 `ACC` 为默认操作数和结果寄存器
- 许多指令默认将运算结果保存在 `ACC` 中, 例如 `ADD`, `ANL`, `ORL`, `XRL`
- 同时参与奇偶校验判断 (与 `P` 标志位相关) 

=== 程序状态字 `PSW (Program Status Word)`

`PSW.7~0` 分别为: `CY`, `AC`, `F0`, `RS1`, `RS0`, `OV`, `F1`, `P`

- `CY (PSW.7)`: 进位 / 借位标志, 反映最高位运算时是否有进位
- `AC (PSW.6)`: 辅助进位 (Auxiliary Carry) 标志。当D3位向D4位产生进位或借位时（主要在BCD运算中），`AC`置1，否则清0。此标志主要用于十进制调整指令，如 `DA A`。
- `F0, F1 (PSW.5 / PSW.1)`: 用户可定义的通用标志位，可由软件自由设置与读取。
- `RS1, RS0 (PSW.4 / PSW.3)`: 工作寄存器组选择位。通过这两位可以选择4组工作寄存器 (R0-R7) 中的当前活动组。
  #table(columns: 3, align: center, [*RS1*], [*RS0*], [*选定寄存器组及地址范围*], [0], [0], [第0组 (00H-07H)], [0], [1], [第1组 (08H-0FH)], [1], [0], [第2组 (10H-17H)], [1], [1], [第3组 (18H-1FH)])
- `OV (PSW.2)`: 溢出 (Overflow) 标志。在带符号数算术运算中，当结果超出8位带符号数的表示范围 (-128 到 +127) 时，`OV`置1，否则清0。
- `P (PSW.0)`: 奇偶 (Parity) 标志。根据累加器 `ACC` 中 '1' 的个数来设置。若 `ACC` 中 '1' 的个数为奇数，则 `P=1`；若为偶数，则 `P=0`。

=== 算术逻辑单元 `ALU`

- 用于执行 *加法、减法、逻辑与/或/异或、比较、移位* 等基本运算
- 运算结果通常保存在 `ACC` 中, 必要时设置 `PSW` 相应标志位
- 是实现数据处理和布尔逻辑的物理核心

=== 暂存寄存器 `TMP`

用于运算数据的暂时存放, 该寄存器不能访问. 

=== 布尔处理器 (位处理器)

- 具有 *强大的位操作能力*, 可位寻址、测试、置位、清零、取反等
- 能直接操作特殊功能寄存器中的位, 如 `SETB TR0`, `CLR IE.7`

能直接对位 (bit) 进行操作, 操作空间是位寻址空间. 位处理器中
功能最强、使用最频繁的位是C, 也称其为位累加器. 

== 存储器

- 数据存储器 RAM (Random Access Memory)
- 程序存储器 ROM (Read Only Memory)

以下三条指令用于不同存储器之间的数据访问: 
- `MOV`: 用于访问 *内部 RAM* 与 *特殊功能寄存器 (SFR) *
- `MOVX`: 用于访问 *外部 RAM*
- `MOVC`: 用于访问 *程序存储器 ROM*, 常用于查表等操作

=== 程序存储器

- 分为内部和外部ROM
- $overline(E A) = 1$表示内部, 为$0$ 表示外部. 

- `00H~7FH` 低128字节 内部RAM区
  - 工作寄存区
  - 位寻址区
  - 用户寄存区
- `80H~FFH` 高128字节 专用寄存器

*特殊区域*

- `0000H~0002H` `PC`指针复位处
- `0003H~000AH` 外部中断0中断地址区
- `000BH~0012H` 定时器/计数器0中断区
- `0013H~001AH` 外部中断1中断地址区
- `001BH~0022H` 定时器/计数器1中断区
- `0023H~002AH` 串行中断地址区

=== 数据存储器

MCS-51 的数据存储空间由 *内部 RAM* 与 *外部 RAM* 构成: 

- 内部 RAM: `00H ~ FFH` 共 256 字节
  - `00H ~ 7FH` (低 128 字节): 
    - `00H ~ 1FH`: *工作寄存器区*, 分为 4 组 R0~R7
    - `20H ~ 2FH`: *位寻址区*, 可使用 `SETB`, `CLR` 等位操作
    - `30H ~ 7FH`: *用户通用 RAM 区*, 供数据读写
  - `80H ~ FFH` (高 128 字节): 
    - 实际上是 *特殊功能寄存器区 (SFR) *, 如 `P0`、`TMOD`、`IE` 等
    - 注意: 并非全部地址都被定义或使用

- 外部 RAM: 
  - 最大支持 `64KB` (地址范围 `0000H`~`FFFFH`)，通过 `MOVX` 指令访问。
  - 访问外部RAM时，通常需要使用 `P0` 口作为数据/地址复用总线，`P2`口作为高8位地址总线（当使用16位地址如DPTR时）。
  - 需配合外部地址锁存器 (如 74HC573 或 74LS373) 来分离 `P0` 口的地址和数据，以及适当的片选和读写控制逻辑。

=== 存储器总结与空间分配

#figure(
  image("assets/storage-config.png"), 
  caption: [MCS-51存储器空间概览 (内部与外部)]
)

== 控制器引脚

最小系统: *晶振、复位、电源、时钟、EA (外部访问) *

=== 时钟引脚

- 用于接晶振电路, 提供系统时钟信号. 

- 系统内部通过时钟频率分频生成: 

  - 2 分频 → 状态时钟
  - 6 分频 → ALE 信号
  - 12 分频 → 机器周期时钟

- 振荡周期: 
  $ T_c = frac(1,f_"osc") $

- 状态周期 (不常用): 
  $ T_s = 2 T_c $

- 机器周期 (常用于时间计算): 
  $ T_m = 6 T_s = 12 T_c $

- 指令周期: 执行一条指令所需的机器周期数 (依指令不同可能为 1、2 或 4 个 $T_m$) 

=== 复位引脚

复位电路 (支持上电复位与手动复位): 

#figure(
  image("assets/mannual-reset.png", height: 40%),
  caption: [手动复位电路]
)

=== 控制引脚: `ALE` / `PSEN`

- `ALE` (Address Latch Enable): 

  - 地址锁存允许信号. 
  - 用于将 P0 的低 8 位地址锁存进 74HC573 等锁存器. 
  - 正常工作状态下为 1/6 分频输出, 可用于观察系统是否运行. 

- `PSEN` (Program Store Enable): 

  - 程序存储器读选通信号. 
  - 外部程序存储器 (ROM) 选通信号, 低电平有效. 

=== `P0` 口

- 为复用型口线: 在访问外部存储器时 (执行 `MOVX` 或 `MOVC` 指令)，`P0`口分时复用作低8位地址总线 (A0-A7) 和8位数据总线 (D0-D7)。
- 与其他 P 口不同，`P0`口内部*没有上拉电阻* (开漏输出)。因此，当 `P0`口用作通用I/O输出口并需要输出高电平时，或者作为总线接口连接多个设备时，必须外接上拉电阻 (通常为10KΩ左右的电阻排或独立电阻到VCC)。
- 作为通用输入口时: 必须先向 `P0`口锁存器写入全1 (`MOV P0, #0FFH`)，使其引脚浮空（由外部上拉电阻拉高），然后才能正确读取外部信号状态。
- 作为通用输出口时: 直接向 `P0`口锁存器写入数据即可。

=== 其他 P 口输入说明 (P1、P2、P3) 

- 默认带内部上拉电阻. 
- 读取输入时, 也需先写入高电平, 然后再读取电平状态. 

`P3`口除了可以用作通用I/O端口, 同时还具有特定的第二功能. 

#table(
  fill: (x, y) => if y == 0 {luma(80%)},
  align: center,
  columns: (auto, auto, 1fr),

  [*I/O引脚*], [*第二功能引脚名称*], [*说明*],
  `P3.0`, `RXD`, [串行通信的数据接收端口],
  `P3.1`, `TXD`, [串行通信的数据发送端口],
  `P3.2`, overline(`INT0`) , [外部中断 0 的请求端口],
  `P3.3`, overline(`INT1`) , [外部中断 1 的请求端口],
  `P3.4`, `T0`, [定时/计数器 0 的外部事件计数输入端],
  `P3.5`, `T1`, [定时/计数器 1 的外部事件计数输入端],
  `P3.6`, overline(`RD`) , [外部数据存储单元的读选通信号],
  `P3.7`, overline(`WR`) , [外部数据存储单元的写选通信号],
)

= 指令系统

== 指令格式

```asm
ANNOTATION: COMMAND TARGET, SOURCE  ; comment
```

指令格式说明: MCS-51的指令可以是不带操作数的单字节指令（如 `NOP`, `RET`），也可以是带一个或多个操作数的指令，长度从一字节到三字节不等。操作码明确了CPU要执行的操作类型，而操作数则是这些操作的对象或参与运算的数据。

== 寻址方式

- 立即寻址
- 直接寻址
- 寄存器寻址
- 间址寻址
- 变址寻址
- 相对寻址
- 位寻址

=== 立即寻址

操作数以立即数的形式在指令中直接给出，立即数表示为`#data`，`#data16`。数字前加“\#”符号，即表示为立即数。

例如: 
```asm
MOV  A, #30H
MOV  DPTR, #8000H
ADD  A, #05H  ; A = A + 05H
```

=== 直接寻址

指令中给出的操作数是实际操作数的存储地址，即存放实际操作数的内部RAM的单元地址或SFR的地址，该单元的内容为指令的操作数。
对比两种区别: 
```asm
MOV 30H, 50H   ; 操作码  直接地址  直接地址
               ; 85       30       50
MOV 30H, #50H  ; 操作码  直接地址  立即数
               ; 75       30       50
```

直接寻址的寻址空间（数据空间RAM）：
- 内部RAM的低128个字节单元（`00H`~`7FH`）
- 特殊功能寄存器区（SFR, Special Function Register）。直接寻址是访问SFR的*唯一方式*。例如，`ACC` (或 `E0H`), `PSW` (或 `D0H`), `P0` (或 `80H`) 等都是SFR。

例如:
```asm
MOV PSW, #00H  ; 将PSW寄存器的值设为00H, 选择R0-R7为第0组工作寄存器
```

=== 寄存器寻址

指令中给出操作数所在的寄存器，即寄存器的内容是操作数。
```asm
MOV A, R1 
INC R0
ADD A, R0  ; A = A + R0
```
（该类指令大多数为单字节指令，操作数隐含在操作码中）
寄存器寻址空间为：工作寄存器 R0~R7 (由PSW中的RS1, RS0选择当前组)，累加器 A，B寄存器，DPTR (某些指令)。

=== 寄存器间接寻址

操作数的地址存放在寄存器中，即寄存器的内容是操作数所在的内存地址。
用于间接寻址的寄存器有R0, R1 (用于访问内部RAM或外部RAM的低256字节) 和 DPTR (用于访问外部RAM的64KB空间)。寄存器名前加 `@`符号表示间接寻址。

*访问内部RAM:*
```asm
MOV A, @R0  ; 将R0内容所指向的内部RAM单元的内容送A
MOV @R1, B  ; 将B寄存器的内容送R1内容所指向的内部RAM单元
```

*访问外部RAM:*
```asm
MOVX A, @DPTR   ; (外部RAM读) 将DPTR内容所指向的外部RAM单元的内容送A
MOVX @R1, A     ; (外部RAM写) 将A的内容送R1内容所指向的外部RAM单元 (仅P2口送高8位地址, P0口送低8位地址, 适用于较小范围的外部RAM)
MOVX @DPTR, A   ; (外部RAM写) 将A的内容送DPTR内容所指向的外部RAM单元
```
注意: `MOVX @Ri, A` 指令中, `Ri` 只能是 `R0` 或 `R1`, 并且通常与P2口配合使用以提供高8位地址, P0口提供由 `Ri` 指定的低8位地址。

=== 变址寻址

以`DPTR`或`PC`作*基址寄存器*，`A`作*变址寄存器*（存放8位无符号数），两者相加形成的16位程序存储器地址，作为操作数所在地址。
8051微控制器共有3条变址寻址的指令（均为单字节指令）
```asm
MOVC A, @A+DPTR  ; 程序存储器查表 (DPTR为基址, A为偏移)
MOVC A, @A+PC    ; 程序存储器查表 (PC为基址, A为偏移)
JMP  @A+DPTR     ; 无条件跳转 (DPTR为基址, A为偏移)
```

变址寻址空间为：*程序存储器 (ROM)*。这种寻址方式非常适合于从存储在程序存储器中的表中读取数据或实现跳转表。

-   `MOVC A, @A+DPTR`:
    这是最常用的查表指令。`DPTR` 存放数据表的基地址 (首地址)，累加器 `A` 中存放的是相对于基地址的偏移量。执行指令后，`(DPTR + A)` 指向的程序存储器单元的内容被传送到累加器 `A`。
    例如，查找七段数码管的显示码：
    ```asm
    MOV  DPTR, #SEG_TABLE ; DPTR 指向七段码表首地址
    MOV  A, #02H          ; 要查找数字2的段码, A作为索引
    MOVC A, @A+DPTR       ; A中将得到数字2对应的七段码
    ; ... further instructions ...

    ORG  0F00H            ; 假设表格从0F00H开始
    SEG_TABLE:
      DB 0C0H  ; 数字0的段码 (共阳极)
      DB 0F9H  ; 数字1的段码
      DB 0A4H  ; 数字2的段码
      DB 0B0H  ; 数字3的段码
      ; ... 其他数字的段码 ...
    ```

-   `MOVC A, @A+PC`:
    这条指令使用程序计数器 `PC` 作为基址寄存器。`PC` 的值是*下一条指令的地址*。累加器 `A` 中存放偏移量。执行时，`(PC + A)` 指向的程序存储器单元的内容被传送到累加器 `A`。
    这种方式适用于数据表较小且紧跟在指令之后的情况，称为近程查表。例如，一小段本地化的数据转换表。

-   `JMP @A+DPTR`:
    这是一条无条件跳转指令。`DPTR` 存放跳转表的基地址，`A` 中的内容为偏移量。执行后，程序将跳转到 `(DPTR + A)` 所指向的地址继续执行。常用于实现多分支跳转 (类似于 `switch-case` 结构)。
    例如，根据A中的值跳转到不同的处理程序：
    ```asm
    MOV  DPTR, #JUMP_TABLE ; DPTR 指向跳转表
    MOV  A, #INDEX_VAL     ; INDEX_VAL决定跳转到哪个分支 (0, 1, 2...)
    RL   A                 ; 乘以2, 因为跳转表每项占2字节 (LJMP是3字节, AJMP是2字节, 这里假设是AJMP或地址偏移量)
                           ; 如果跳转表存的是直接的地址偏移量 (1字节)，则不需要RL A
                           ; 如果跳转表存的是LJMP指令，则需要 A * 3
    JMP  @A+DPTR

    JUMP_TABLE:
      AJMP CASE0_ADDR
      AJMP CASE1_ADDR
      AJMP CASE2_ADDR
      ; ...
    ```

=== 相对寻址

用于程序控制，利用指令修改PC指针内容实现转移。指令中给出的操作数为程序转移的偏移量（relative）。以PC当前值（执行这条指令时的PC）加上偏移量，所得结果即为转移的目的地址。
$
  "目的地址" & = "PC值（转移指令下一条指令的首址）" + "rel" \
  & = "（转移指令所在地址 + 转移指令字节数）" + "rel"
$
例如 `SJMP rel`, `JZ rel`, `JNZ rel`, `DJNZ Rn, rel`, `CJNE A, #data, rel` 等。 `rel` 是一个用补码表示的8位带符号数，其表示的偏移范围是 -128 到 +127 字节。

*偏移量 `rel` 的计算:*

汇编器会自动计算 `rel` 的值。手动计算 `rel` 的公式为：
`rel = 目标地址 - (当前指令地址 + 指令字节数)`

如果 `rel` 是负数，其补码表示为 `256 - abs(rel)`。

*示例：*
考虑以下 `DJNZ` 指令的循环：
```asm
    ORG  0100H
    MOV  R0, #10     ; 0100H, 2字节指令. R0 < - #10
    ;
LOOP:                ; 循环开始地址, 假设为 0102H
    ; ... 一些指令 ...
    ; 假设这些指令共占 M 字节
    ; ...
    ; 假设 DJNZ 指令位于地址 010AH
    DJNZ R0, LOOP    ; 010AH, 2字节指令. R0 < - R0 - 1, 若R0不为0, 则跳转到LOOP
NEXT:                ; DJNZ 指令执行后 R0为0时, 程序从这里继续, 地址为 010AH + 2 = 010CH
    ; ...
```

在上面的例子中：
- `DJNZ R0, LOOP` 指令位于地址 `010AH`。
- 这是一条2字节指令。
- `PC` 在执行这条指令时，其值会是下一条指令 `NEXT` 的地址，即 `010AH + 2 = 010CH`。
- 目标地址 `LOOP` 是 `0102H`。

所以，`rel` 的计算如下:
`rel = 目标地址 (LOOP) - PC值 (NEXT)`
`rel = 0102H - 010CH`
`rel = -0AH` (十进制为 -10)

由于 `rel` 是一个8位带符号数，-0AH 的补码表示为：
`0FAH` (因为 `11111010B`，最高位为1表示负数，其值为 `-(2^8 - 0FAH) = -(256 - 250) = -10`)。
或者用 `256 - 10 = 246 = 0FAH`。

所以，汇编器会将 `DJNZ R0, LOOP` 编码为 `D5 R0_direct_addr FA` (假设R0是直接地址，实际DJNZ Rn指令的操作码是针对Rn的)。对于 `DJNZ R0, rel`，操作码是 `D8H` 到 `DFH` (取决于R0-R7)，这里假设是 `D5` (这是 `DJNZ direct, rel` 的操作码，仅为示意，实际 `DJNZ R0, rel` 是 `D8 rel`)。更准确地说，如果 `DJNZ R0, LOOP`，操作码为 `D8`，则机器码为 `D8 FA`。

如果跳转的目标地址在当前指令之后 (向前跳转)，`rel` 将是一个正数。

=== 位寻址

SFR中的可寻址位既有位地址又有符号名称，如PSW的位7为，其位地址为D7H；P0的位0为P0.0，位地址为80H。建议在指令中使用位符号名称，以增加程序的可读性。
```asm
MOV C, P1.0   ; 将P1口P1.0引脚的状态送入进位标志位 C
SETB P1.0   ; 将P1口的P1.0引脚置为1 (高电平)
CLR  TR0    ; 清零TR0 (TCON.4), 停止定时器0的运行
MOV  C, P0.7 ; 将P0口P0.7引脚的状态送入进位标志位 C
ANL  C, P0.0 ; 将P0.0与C相与，结果存回C
ORL  C, /P3.2; 将P3.2取反后与C相或，结果存回C (/表示对位取反)
```
位寻址（对于位）与直接寻址（对于字节）的地址形式有时可能看起来相同（例如，直接地址 `20H` 也是位地址 `20H.0` 开始的字节的地址），但具体是字节操作还是位操作由*指令的操作码*决定。

可进行位寻址的区域主要有两部分：
1.  内部RAM中地址从 `20H` 到 `2FH` 的16个字节单元，共 `16 * 8 = 128` 个位。这些位的地址从 `00H` 到 `7FH`。
2.  大部分特殊功能寄存器 (SFR) 中的可位寻址的位。每个可位寻址的SFR位都有一个特定的位地址。

为提高程序的可读性，对于SFR中的位地址，通常建议使用其*符号名称* (如 `TR0`, `EA`, `P1.0`) 而不是直接使用其位地址 (如 `8CH`, `0AEH`, `90H`)。

例如，可位寻址的SFR位包括：
- `ACC` (E0H): `ACC.0` 到 `ACC.7` (位地址 `0E0H` 到 `0E7H`)
- `B` (F0H): `B.0` 到 `B.7` (位地址 `0F0H` 到 `0F7H`)
- `PSW` (D0H): `P` (D0H), `OV` (D2H), `RS0` (D3H), `RS1` (D4H), `AC` (D6H), `CY` (D7H)
- `P0` (80H), `P1` (90H), `P2` (A0H), `P3` (B0H)
- `IP` (B8H), `IE` (A8H)
- `TCON` (88H): `IT0` (88H), `IE0` (89H), `IT1` (8AH), `IE1` (8BH), `TR0` (8CH), `TF0` (8DH), `TR1` (8EH), `TF1` (8FH)
- `SCON` (98H): `RI` (98H), `TI` (99H), `RB8` (9AH), `TB8` (9BH), `REN` (9CH), `SM2` (9DH), `SM1` (9EH), `SM0` (9FH)

(注意：上面列出的位地址是十六进制的，例如 `ACC.0` 的位地址是 `0E0H`，`CY` 的位地址是 `0D7H`。)

=== 寻址方式比较总结

- *特殊功能寄存器 (SFR)*:
  - 只能使用*直接寻址*方式访问。例如 `MOV A, PSW` 或 `MOV IE, #10000001B`。
  - SFR的地址范围为 `80H` 到 `FFH`。
- *内部RAM低128字节 (`00H` - `7FH`)*:
  - 可以使用*直接寻址*。例如 `MOV A, 30H`。
  - 可以使用*寄存器间接寻址* (通过 `@R0` 或 `@R1`)。例如 `MOV A, @R0`。
  - 工作寄存器区 (`00H`-`1FH` 根据PSW设置) 和位寻址区 (`20H`-`2FH`) 属于此范围。
- *内部RAM高128字节 (`80H` - `FFH`)*:
  - 这部分地址与SFR地址重叠。
  - 如果使用*直接寻址*，访问的是SFR。例如 `MOV A, 0E0H` 访问的是累加器A本身。
  - 如果要访问此地址范围内的RAM单元 (如果芯片支持256字节内部RAM，如8052)，则*必须使用寄存器间接寻址* (通过 `@R0` 或 `@R1`)。例如，若R0值为 `0E0H`，`MOV A, @R0` 访问的是内部RAM的 `0E0H`单元，而不是累加器A。
- *外部数据存储器 (RAM, 最高64KB)*:
  - 只能使用 `MOVX` 指令配合*寄存器间接寻址* (`@DPTR`, `@R0`, `@R1`) 访问。
- *程序存储器 (ROM, 最高64KB)*:
  - CPU取指令时自动按 `PC` 指针访问。
  - 使用 `MOVC` 指令配合*变址寻址* (`@A+DPTR` 或 `@A+PC`) 读取数据。

== 数据传送类

数据传送类指令是最基本、使用最多的一类指令，共有29条。主要用于*数据的传送、保存以及交换*等场合。\
该类指令中，除给`A`赋值（`A`内容发生变化）会影响`P`标志外，其余标志不受影响。可分为以下五组：
#align(
  center, 
  grid(
    columns: 2, 
    align: left, 
    inset: 3pt,
    [内部RAM数据传送类指令: ], [16条 (`MOV`)], 
    [程序存储器访问类指令: ], [2条 (`MOVC`)], 
    [外部RAM访问类指令: ], [4条 (`MOVX`)], 
    [堆栈操作类指令: ], [2条], 
    [数据交换类指令: ], [5条]
  )
)

#let e(body) = text(body, weight: "bold", fill: blue)

=== 内部RAM数据传送类指令

#e("MOV")

该组指令实现8051MCU内部工作寄存器、存储单元、SFR之间的数据传送。
```asm
MOV TARGET, SOURCE
```

#align(
  center,
  block(
    width: 50%,
    table(
      columns: (1fr, 1fr), 
      `TARGET`, `SOURCE`, 
      table.cell(`A`, rowspan: 4),
      `Rn`, `direct`, `@Ri`, `#data`, 
      table.cell(`direct`, rowspan: 5), 
      `A`, `Rn`, `direct`, `@Ri`, `#data`, 
      table.cell(`Rn`, rowspan: 3), 
      `A`, `direct`, `#data`, 
      table.cell(`@Ri`, rowspan: 3), 
      `A`, `direct`, `#data`, 
      `DPTR`, `data16`
    )
  )
)

*注意*: 以下是一些不允许的 `MOV` 指令（非法指令）示例，主要因为操作数类型不匹配或操作方式不支持：
```asm
; MOV Rn, Rn        ; 寄存器到自身的传送虽然逻辑上无意义，但并非所有汇编器都视其为非法。
MOV @Ri, @Rj      ; 内部RAM间接地址 到 内部RAM间接地址 (不允许直接传送)
MOV #data, direct ; 立即数 不能作为 目的操作数
MOV P1, P0        ; SFR到SFR的直接传送 (对于端口P0-P3，通常需要通过ACC中转)
; MOV direct1, direct2 ; 直接地址到直接地址的传送 (这条实际上是合法的，但可能被汇编器转为多条指令)
```
更明确地说，不允许的传送类型主要包括：
- 两个工作寄存器 `Rn` 与 `Rm` 之间不能直接用 `MOV` 指令传送数据 (通常需通过累加器 `A`)。
- 两个间接寻址的内部RAM单元 (`@Ri`, `@Rj`) 之间不能直接传送。
- 立即数 (`#data`) 不能作为目的操作数。
- 大部分特殊功能寄存器 (SFR) 之间不能直接传送数据（通常需要通过累加器 `A`）。例如，`MOV P1, P0` 是非法的。
- 从代码存储器到数据存储器的直接 `MOV` (应使用 `MOVC` 或 `MOVX` 指令配合)。

=== 外部RAM访问类指令

#e("MOVX") ; 访问外部数据存储器 (External Data RAM Access)

该组指令实现8051MCU与外部RAM的数据传送。

```asm
MOVX A,     @DPTR          
MOVX A,     @Ri               
MOVX @DPTR, A         
MOVX @Ri,   A 
```

=== 查表指令

#e("MOVC") ; 访问程序存储器 (Code Memory Access)

该组指令的功能是从ROM中读取数据，通常是对存放在ROM中的数据表格进行查找读取。

i. 远程查表

```asm
MOVC A, @A+DPTR
```

- 功能：将`DPTR`的内容与`A`的内容相加后形成一个ROM单元地址，将该ROM单元的内容送至`A`。DPTR内容不变。
- 基址寄存器`DPTR`是常数，指向数据表格的首地址；
- 变址寄存器`A`为表格首址到被访问数据的地址偏移量；
- `DPTR` 、 `A`都可以改变，`A`的范围是`0-255`；
- DPTR的范围是`0000H-0FFFFH`。

- 优点：可以查找存放在64K ROM中任何地址的数据表格，因此称为远程查表指令。
- 缺点：要占用`DPTR`寄存器。

ii. 近程查表

```asm
MOVC A, @A+PC
```

- 功能：将`A`和当前`PC`值相加，形成要寻址的ROM单元地址，将该ROM单元中的内容送到A。
- 注意：当前`PC`值，应为该指令所在地址加1。

- 优点：不占用其他的SFR，不改变`PC`的值。根据`A`的内容就可查到数据。
- 缺点：只能查找该指令后256字节范围内的数据表格，因此称为近程查表指令

=== 堆栈操作指令

该组指令采用*直接寻址方式*，入栈操作是把直接寻址单元的内容传送到堆栈指针SP所指的单元中，出栈操作是把SP所指单元的内容送到直接寻址单元中。

```asm
PUSH direct ; 先修改SP指针，再将内部RAM  direct单元的内容压入堆栈。
POP  direct ; 将堆栈栈顶的内容弹出，送到内部RAM direct单元，再修改SP指针。
```

=== 数据交换指令

该组指令是把A中的内容与源操作数所指的数据相互交换。有整字节交换和半字节交换。

- #e("XCH") ; EXCHANGE (字节交换)
- #e("XCHD") ; EXCHANGE LOW-ORDER DIGIT (低半字节交换)
- #e("SWAP") ; SWAP NIBBLES IN A (累加器A中高低半字节交换)

```asm
XCH  A, Rn
XCH  A, direct
XCH  A, @Ri
XCHD A, @Ri
SWAP A
```

== 算数运算类

算术运算指令是通过算术逻辑运算单元 ALU 进行数据运算与处理的指令，主要完成加、减、乘、除四则运算，以及加 1 、减 1 、BCD 码运算和调整等。除加 1 、减 1 运算外，这类指令大多数要影响 `PSW` 中的标志位。 24 条指令可分为 6 组。

=== 不带进位加法指令

#e("ADD") ; ADDITION

```asm
ADD A, #data
ADD A, direct
ADD A, @Ri
ADD A, Rn
```

将源操作数（Rn、direct、\@Ri或立即数）和目的操作数（在A中）相加后，结果存放到A中。

- 无符号数相加时，如果Cy被置位，说明累加和超过了8位无符号数的最大值（255），此时OV虽受影响但无意义；
- 带符号数相加时，若溢出标志OV位被置位，说明累加和超出了8位带符号数的范围（-128~+127）。即出现了两个正数相加，和为负数；或两个负数相加，和为正数的错误结果。此时Cy虽受影响但已不需关注。

=== 带进位加法指令

#e("ADDC") ; ADDITION WITH CARRY

```asm
ADDC A, #data
ADDC A, direct
ADDC A, @Ri
ADDC A, Rn
```

把源操作数、A和当前Cy的值相加，结果保存到A。主要用于多字节加法中。

=== 带借位减法指令

#e("SUBB") ; SUBTRACT WITH BORROW (带借位减法)

```asm
SUBB A, #data
SUBB A, direct
SUBB A, @Ri
SUBB A, Rn
```

将 A 中的值减去源操作数指定的值，以及借位位 Cy ，结果存放在 A 中。

若 D7 有借位则C置 1 ，否则C清 0 ；若 D3 有借位，则 AC 置 1 ，否则 AC 清 0 。\
若 D7 和 D6 中有一位有借位而另一位没有，则 OV 置 1 ；表示正数减负数结果为负，或负数减正数结果为正，结果错误。

- 在进行减法运算前，如果不清楚借位标志位Cy的状态，则应先对Cy进行清0。

=== 加1指令

#e("INC") ; INCREMENT

```asm
INC Rn
INC direct
INC @Ri
INC A
INC DPTR
```

将指令中的操作数加1。

=== 减1指令

#e("DEC") ; DECREMENT

```asm
DEC A
DEC direct
DEC @Ri
DEC Rn
```

指令中的操作数减1。若原操作数为`#00H`，则减1后为`#0FFH`。

=== 乘法指令

#e("MUL") AB ; MULTIPLY A BY B

```asm
MUL AB
```
功能：将累加器 `A` 中的8位无符号数与寄存器 `B` 中的8位无符号数相乘。
结果：16位乘积的高8位存放在寄存器 `B` 中，低8位存放在累加器 `A` 中。
影响标志位：
- `CY`：总是清0。
- `OV` (溢出标志)：如果乘积大于255（即 `B` 寄存器内容不为0），则 `OV` 置1；否则 `OV` 清0。此标志可用于判断结果是否超出一个字节。

=== 除法指令

#e("DIV") AB ; DIVIDE A BY B

```asm
DIV AB
```
功能：将累加器 `A` 中的8位无符号数（被除数）除以寄存器 `B` 中的8位无符号数（除数）。
结果：8位商存放在累加器 `A` 中，8位余数存放在寄存器 `B` 中。
影响标志位：
- `CY`：总是清0。
- `OV` (溢出标志)：如果除数 `B` 为0，则 `OV` 置1，表示除法错误（溢出）；否则 `OV` 清0。当 `OV=1` 时，`A` 和 `B` 中的内容是未定义的。

=== 十进制调整指令

#e("DA") A ; DECIMAL ADJUST ACCUMULATOR (十进制调整)

```asm
DA A
```

对两个压缩BCD码（一个字节存放2位BCD码）数相加的结果进行十进制调整

注意：
- 只能用在ADD和ADDC指令之后，对相加后存放在。
- 两个压缩BCD码按二进制数相加之后，必须经过此指令的调整才能得到正确的BCD码累加和结果。
调整的条件和方法：
- 若（`A0~3`） > 9或（`AC`）＝1，则（`A0~3`）#sym.arrow.l（`A0~3`）+6，即低位加6调整。
- 若（`A4~7`） > 9或（`Cy`）＝1，则高位加6调整。
- `DA A` 指令对C的影响是只能置位，不能清0。

== 逻辑操作类

逻辑操作类指令包含逻辑与、逻辑或、逻辑异或、求反、左右移位、清0等。该类指令不影响标志位，仅当其目的操作数为A时，对奇偶标志位P有影响。24条指令可分为5组。

=== 逻辑与

#e("ANL") ; AND LOGIC

```asm
ANL A,      Rn
ANL A,      direct
ANL A,      @Ri
ANL A,      #data
ANL direct, A
ANL direct, #data
```

将目的操作数和源操作数按“位”相“与”，结果存放到目的操作数单元中。

=== 逻辑或

#e("ORL") ; OR LOGIC

```asm
ORL	A,      Rn
ORL	A,      direct
ORL	A,      @Ri
ORL	A,      #data
ORL	direct, A
ORL	direct, #data
```

将目的操作数和源操作数按“位”相“或”，结果存放到目的操作数单元中。 

=== 逻辑异或

#e("XRL") ; EXCLUSIVE-OR LOGIC (逻辑异或)

```asm
XRL A,      Rn
XRL A,      direct
XRL A,      @Ri
XRL A,      #data
XRL direct, A
XRL direct, #data
```

将目的操作数和源操作数按“位”相“异或”，结果存放到目的操作数单元中。

“异或”的逻辑是：两位相异时结果为1，相同时结果为0。常用于使特定位翻转（与全1异或）或比较两值是否相等（结果为0则相等）。

=== 清零与取反指令

#e("CLR") A ; CLEAR ACCUMULATOR (累加器清零)
#e("CPL") A ; COMPLEMENT ACCUMULATOR (累加器取反)

```asm
CLR A  ; 将累加器A的内容清0 (所有位置0)
CPL A  ; 将累加器A的内容按位取反 (1变0, 0变1)
```
`CLR A` 是唯一的可以将累加器A所有位清零的单字节指令。
`CPL A` 对累加器A的内容逐位取反，结果仍保留在A中。

=== 循环移位指令

```asm
RL  A ; 循环左移指令
; A的内容循环左移一位。(Rotate Left)
RR  A ; 循环右移指令
; A的内容循环右移一位。(Rotate Right)
RLC A ; 带C的循环左移
; A的内容和C的内容整个左移一位。(Rotate Left through Carry)
RRC A ; 带C的循环右移
; A的内容和C的内容整个右移一位。(Rotate Right through Carry)
```

=== 使用技巧

+ 逻辑“与”操作的位屏蔽: 清除的位 and 0
+ 逻辑“或”操作的置位: 保留 or 0; 置1 or 1
+ 逻辑“异或”操作的求反: 保留 xor 0; 取反 xor 1

== 控制转移类

程序的顺序执行是由程序计数器（`PC`）自动增1来实现的，要改变程序的执行顺序，控制程序的流向，必须通过控制转移类指令实现，所控制的范围为程序存储器的64KB空间。8051MCU的控制转移类指令，共17条，可分为4组。

=== 无条件转移指令 (Unconditional Jump)

```asm
LJMP addr16  ; 长跳转指令（Long Jump）
             ; 跳转范围为 64K，PC ← addr16
             ; 3字节指令

AJMP addr11  ; 绝对跳转指令（Absolute Jump）
             ; 跳转范围为 2K
             ; PC = (PC) + 2，PC 的低 11 位 ← addr11
             ; 2字节指令

SJMP rel     ; 短跳转指令（Short Jump）
             ; 跳转范围为 -128 ~ +127
             ; 2字节指令（含偏移）

JMP  @A+DPTR ; 间接跳转指令（Jump Indirect）
             ; PC ← A + DPTR（A为8位无符号数）
             ; 1字节指令
```

原则上，用`SJMP`或`AJMP`的地方都可以用`LJMP`替代。`AJMP`已很少使用。

#grid(
  columns: (1fr, auto), 
  align: center+horizon, 
  inset: 5pt,
  card(title: [散转指令])[
  散转指令是一条无条件转移指令，`JMP @A+DPTR`可代替众多
  的判别跳转指令，具有散转功能。该指令的基址寄存器是DPTR，变
  址寄存器是A，由于A内容的不同，使程序转移到相对于DPTR偏移
  量为A内容的地址处，执行分支程序。
  ],
  [$ "rel" = "目的地址" - ("转移指令所在地址" + "转移指令字节数") $ rel是一个带符号数的8位二进制补码数，\ 其范围为（-128）-（+127）]
)

=== 条件转移指令

i. 判零转移指令 (Jump if Zero/Not Zero)

```asm
JZ rel ; Jump if ACC equal Zero
    ; A=0, 跳。 (PC) ← (PC) + 2 + rel
    ; A≠0, 不跳，继续向下执行。即(PC) ← (PC) + 2

JNZ rel ; Jump if ACC Not equal Zero
    ; A≠0, 跳。 (PC) ← (PC) + 2 + rel
    ; A=0, 不跳，继续向下执行。即(PC) ← (PC) + 2
```

ii. 数值比较转移指令 (Compare and Jump if Not Equal)

#e("CJNE") ; COMPARE AND JUMP IF NOT EQUAL

```asm
CJNE A,   direct, rel
CJNE A,   #data,  rel
CJNE Rn,  #data,  rel
CJNE @Ri, #data,  rel
```

对指定的两操作数进行比较，即(操作数1)－(操作数2)，比较结果仅影响标志位C，2个操作数的值不变；

iii. 循环转移指令 (Decrement and Jump if Not Zero)

#e("DJNZ") ; DECREMENT AND JUMP IF NOT ZERO

```asm
DJNZ Rn, rel ; Decrement Rn and jump if not zero
    ; (Rn) ← (Rn) - 1
    ; If (Rn) ≠ 0, jump, (PC) ← (PC) + 2 + rel
    ; If (Rn) = 0, do not jump, (PC) ← (PC) + 2

DJNZ direct, rel ; Decrement direct address and jump if not zero
    ; The content of direct address is used as the basis for judgment
```

- Rn或direct的内容减1，判别其内容是否为0。
- 若不为0，跳转到目标地址，继续执行循环程序；
- 若为0，则结束循环程序段，程序往下执行。

=== 空操作指令 (No Operation)

#e("NOP") ; NO OPERATION

```asm
NOP
```
该指令不执行任何操作 (`No OPeration`)，仅占用一个机器周期的时间使 `PC` 指针加1。常用于短延时、为后续指令对齐地址，或在调试过程中临时移除指令。

=== 子程序调用和返回指令 (Subroutine Call and Return)

- 长调用 #e("LCALL") `addr16` (Long Call)
- 绝对调用 #e("ACALL") `addr11` (Absolute Call)
- 子程序返回 #e("RET") (Return from Subroutine)
- 中断返回 #e("RETI") (Return from Interrupt)

== 位操作指令

=== 位传送指令 (Bit Transfer Instructions)

```asm
MOV C, bit    ; 将指定位(bit)的状态传送到进位标志位C
MOV bit, C    ; 将进位标志位C的状态传送到指定位(bit)
```

=== 位状态设置指令 (Bit Status Setting Instructions)

#table(
  columns: (auto, 1fr, 1fr), 
  [*功能*], [*助记符*], [*操作对象*],
  [清零], `#e("CLR")`, [`C` 或 `bit`],
  [置1], `#e("SETB")`, [`C` 或 `bit`],
  [取反], `#e("CPL")`, [`C` 或 `bit`],
)
例如：`CLR C`, `SETB P1.0`, `CPL ACC.7`。

=== 位逻辑运算 (Bit Logical Operations)

#table(
  columns: (auto, 1fr, 1fr), 
  [*功能*], [*助记符*], [*操作*],
  [位与], `#e("ANL")`, [`C, bit` (C = C AND bit) 或 `C, /bit` (C = C AND NOT bit)],
  [位或], `#e("ORL")`, [`C, bit` (C = C OR bit) 或 `C, /bit` (C = C OR NOT bit)],
)
斜杠 `/` 表示对位操作数取反。

=== 位条件转移指令 (Bit Conditional Jump Instructions)

```asm
JC rel ; 如果进位标志C=1，则跳转到标号处执行程序；如果C=0，则不跳，顺序执行
    ; (Jump if the Carry flag is set)

JNC rel ; 如果进位标志C=0，则跳转；如果C=1，则不跳，顺序执行
    ; (Jump if Not Carry)

JB bit, rel ; 如果位(bit)=1，则跳转；如果位(bit)=0，则不跳
    ; (Jump if the Bit is set)

JNB bit, rel ; 如果位(bit)=0，则跳转；如果位(bit)=1，则不跳
    ; (Jump if the Bit is Not set)

JBC bit, rel ; 如果位(bit)=1，则跳转，并使位(bit)=0；如果位(bit)=0，则不跳
    ; (Jump if the Bit is set and Clear the bit)
```

== 伪指令

与编译器的约定. 

= MCS-51系统扩展与应用基础

== 三总线结构与外部存储器扩展

MCS-51微控制器要与外部存储器（ROM或RAM）或扩展的I/O接口进行数据交换，依赖于其三总线结构：地址总线 (Address Bus, AB)、数据总线 (Data Bus, DB) 和控制总线 (Control Bus, CB)。扩展外部存储器是解决MCS-51内部存储空间不足的常用方法。

=== 三总线架构简介

-   *地址总线 (Address Bus - AB):*
    -   功能：由CPU产生，用于指定要进行读/写操作的存储单元或I/O端口的地址。
    -   宽度：MCS-51的地址总线通常为16位宽 (`A0-A15`)，因此其可直接寻址的地址空间为 $2^{16} = 65536$ 个字节（64KB）。
    -   实现：对于外部存储器访问，`P0`口分时复用提供低8位地址 (`AD0-AD7`)，`P2`口提供高8位地址 (`A8-A15`)。

-   *数据总线 (Data Bus - DB):*
    -   功能：用于在CPU、存储器和I/O设备之间双向传输数据。
    -   宽度：MCS-51的数据总线为8位宽 (`D0-D7`)。
    -   实现：`P0`口在数据传输阶段作为数据总线 (`AD0-AD7`)。

-   *控制总线 (Control Bus - CB):*
    -   功能：承载CPU发出的控制信号，用于同步和管理地址总线与数据总线上的操作，以及协调各部件的工作。
    -   主要控制信号:
        -   `ALE` (Address Latch Enable - 地址锁存允许): CPU在访问外部存储器时，在 `P0` 口输出地址信息的低8位后，发出 `ALE` 信号（通常是高到低跳变），用于将该地址信息锁存到外部的地址锁存器中（如74HC573）。之后 `P0` 口才能用作数据总线。`ALE` 以固定的1/6晶振频率输出脉冲（空闲时），可作为系统时钟参考。
        -   #overline(`PSEN`) (Program Store Enable - 程序存储器允许): 低电平有效。当CPU从外部程序存储器 (ROM) 读取指令或数据 (如 `MOVC` 指令) 时，发出 #overline(`PSEN`) 信号作为读选通信号。通常连接到外部ROM的 #overline(`OE`) (Output Enable) 或 #overline(`CE`) (Chip Enable) 引脚。
        -   #overline(`RD`) (Read - 读控制): P3.7口，低电平有效。当CPU从外部数据存储器 (RAM) 读取数据时 (执行 `MOVX A, @DPTR` 或 `MOVX A, @Ri`)，发出 #overline(`RD`) 信号作为读选通信号。通常连接到外部RAM的 overline(OE) 引脚。
        -   #overline(`WR`) (Write - 写控制): P3.6口，低电平有效。当CPU向外部数据存储器 (RAM) 写入数据时 (执行 `MOVX @DPTR, A` 或 `MOVX @Ri, A`)，发出 #overline(`WR`) 信号作为写选通信号。通常连接到外部RAM的 #overline(`WE`) (Write Enable) 引脚。
        -   #overline(`EA`) (External Access - 外部访问允许): 高电平有效（通常接VCC）时，CPU在复位后从内部程序存储器开始执行指令。当PC值超过内部ROM的容量上限时，自动转向外部程序存储器。若 #overline(`EA`) 接地（低电平），则CPU总是从外部程序存储器 `0000H` 地址开始执行指令，完全忽略内部ROM。

=== 访问外部程序存储器 (ROM)

当CPU需要从外部程序存储器（如EPROM 2764）读取指令码或执行`MOVC`指令时，其接口和时序如下：

-   *引脚连接*:
    -   `P0` 口: 分时复用为地址总线低8位 (A0-A7) 和数据总线 (D0-D7)。
    -   `P2` 口: 作为地址总线高8位 (A8-A15)。若程序存储器容量小于64KB（如仅8KB的2764，需要13根地址线A0-A12），`P2`口的高位部分 (P2.5-P2.7 for A13-A15) 可能不用于寻址，或用于片选译码。
    -   `ALE`: 连接到外部地址锁存器 (如74HC573) 的 `LE` (Latch Enable) 或 `G` (Gate) 引脚。锁存器的输出端 (Q0-Q7) 提供稳定的低8位地址 (LA0-LA7)。
    -   #overline(`PSEN`): 连接到外部ROM的 #overline(`OE`) (Output Enable) 或 #overline(`CS`) (Chip Select) 引脚。

-   *指令读取周期 (概念性步骤)*:
    1.  CPU将16位程序计数器 (`PC`) 的内容作为地址。
    2.  `P2` 口输出PC的高8位 (`A8-A15`)。
    3.  `P0` 口输出PC的低8位 (`A0-A7`)。
    4.  `ALE` 信号产生一个正脉冲（或由高变低），其下降沿触发地址锁存器锁存P0上的A0-A7。此时，完整的16位地址 (`A0-A15`) 已稳定提供给外部ROM。
    5.  #overline(`PSEN`) 信号有效（变为低电平），选中外部ROM并使其输出数据。
    6.  ROM芯片将选定地址单元的指令字节通过数据总线 (P0口，此时已切换为数据模式) 送给CPU。
    7.  CPU读取指令字节后，#overline(`PSEN`) 信号变为无效（高电平）。
    8.  P0口释放数据总线。

-   `MOVC` 指令 (`MOVC A, @A+DPTR` 或 `MOVC A, @A+PC`) 也使用类似的机制通过 #overline(`PSEN`) 从程序存储器空间读取数据。

=== 访问外部数据存储器 (RAM)

当CPU执行 `MOVX` 指令访问外部数据存储器（如RAM 6264）时，接口和时序如下：

-   *引脚连接*:
    -   `P0` 口: 分时复用为地址总线低8位 (A0-A7) 和数据总线 (D0-D7)。
    -   `P2` 口:
        -   当使用 `MOVX @DPTR, ...` 指令时，`P2` 口输出 `DPH` 的内容，即地址的高8位 (A8-A15)。
        -   当使用 `MOVX @Ri, ...` (R0或R1) 指令时，`Ri` 提供8位地址 (A0-A7) 给 `P0`口。此时，`P2` 口输出的是其SFR锁存的内容。这可以用于实现分页寻址，即通过预先设置 `P2` 的值来选择外部RAM的不同“页”或芯片，当外部RAM大于256字节时。如果只访问256字节的外部RAM (如一个RAM芯片的地址由Ri决定)，`P2`的输出可能不直接参与该芯片的寻址，除非有特定的译码电路利用它。
    -   `ALE`: 同样用于锁存 `P0` 口输出的地址低8位。
    -   #overline(`RD`) (P3.7): 连接到外部RAM的 #overline(`OE`) (Output Enable) 引脚，用于读操作。
    -   #overline(`WR`) (P3.6): 连接到外部RAM的 #overline(`WE`) (Write Enable) 引脚，用于写操作。

-   *`MOVX A, @DPTR` (从外部RAM读数据) 周期*:
    1.  CPU将 `DPTR` 的内容作为16位地址。
    2.  `P2` 口输出 `DPH` (A8-A15)。
    3.  `P0` 口输出 `DPL` (A0-A7)。
    4.  `ALE` 信号锁存 `P0` 上的A0-A7。完整的16位地址已提供给外部RAM。
    5.  #overline(`RD`) 信号有效（变为低电平），选中外部RAM并使其输出数据。
    6.  RAM芯片将选定地址单元的数据字节通过数据总线 (P0口，此时为数据模式) 送给CPU。
    7.  CPU读取数据字节到累加器A后，#overline(`RD`) 信号变为无效（高电平）。
    8.  P0口释放数据总线。

-   *`MOVX @DPTR, A` (向外部RAM写数据) 周期*:
    1.  CPU将 `DPTR` 的内容作为16位地址。
    2.  `P2` 口输出 `DPH` (A8-A15)。
    3.  `P0` 口输出 `DPL` (A0-A7)。
    4.  `ALE` 信号锁存 `P0` 上的A0-A7。
    5.  CPU将累加器A的内容送到数据总线 (P0口，此时为数据模式)。
    6.  #overline(`WR`) 信号有效（变为低电平），使外部RAM将数据总线上的数据写入选定的地址单元。
    7.  #overline(`WR`) 信号变为无效（高电平）后，完成写入。
    8.  P0口释放数据总线。

-   *`MOVX @Ri, ...` 指令*:
    -   `Ri` (R0或R1) 提供8位地址 (A0-A7)，通过 `P0` 口输出。`ALE` 锁存此8位地址。
    -   `P2` 口输出其SFR锁存的内容，可用于高位地址或片选译码。
    -   后续的 #overline(`RD`) 或 #overline(`WR`) 操作与 `@DPTR` 方式类似，但地址范围主要由 `Ri` 和 `P2` 的配置决定。

=== 地址译码 (Address Decoding)

-   当系统中扩展了多个外部存储器芯片（如一个ROM和一个RAM，或多个RAM芯片）时，它们共享地址和数据总线。为了确保CPU在某一时刻只与一个芯片通信，需要使用地址译码电路。
-   地址译码电路利用CPU地址总线中未被存储芯片自身使用的较高位地址线（如A13, A14, A15等）来产生唯一的片选信号 (#overline(`CS`) 或 #overline(`CE`)) 给每个存储芯片。
-   例如，可以使用74HC138这样的3-8线译码器。将A13, A14, A15连接到译码器的输入端，其8个输出端就可以分别作为8个不同存储区域（或芯片）的片选信号。
-   通过地址译码，可以将64KB的总地址空间划分为若干个较小的块，每个块对应一个外部存储芯片。

=== 外部存储器接口示意图

下面是一个简化的MCS-51与外部RAM和ROM连接的示意图：
```text
+---------+        +-----------------+        +-----------------+
| MCS-51  |        | Latch (74HC573) |        | External ROM    |
|         |        |                 |        | (e.g., 27C256)  |
|   P0    |------->| D0-D7      Q0-Q7|------->| A0-A7           |
| (AD0-AD7)|--+    +-----------------+        |                 |
|         |  |                                |                 |
|   P2    |--+------------------------------->| A8-A15          |
| (A8-A15)|  |                                |                 |
|         |  |    +-----------------+        |                 |
|   ALE   |------->| LE              |        |       D0-D7     |<--+
|         |  |    +-----------------+        | (Instruction/Data)|  |
|  PSEN#  |--+------------------------------->| OE#             |  |
|         |  |                                +-----------------+  |
|   RD#   |--|-----------------\                                  |
| (P3.7)  |  |                  \       +-----------------+        |
|         |  |                   +----->| External RAM    |        |
|   WR#   |--|------------------------->| WE#             |        |
| (P3.6)  |  |                          | (e.g., 62C256)  |        |
|         |  |                          |                 |        |
|         |  +------------------------->| A0-A7 (from Latch)     | |
|         |  |                          | A8-A15 (from P2)       | |
|         |  |                          |                 |        |
|         |  +--------------------------| D0-D7           |<-------+
|         |                             | OE#             |<--+
+---------+                             +-----------------+
```
*注意: 上述示意图简化了片选(CS)逻辑，实际应用中可能需要地址译码电路来产生针对ROM和RAM的独立片选信号。P0作为数据总线是双向的。*

= 中断系统

MCS-51微控制器提供了一个中断系统，允许微控制器响应内部或外部的特定事件，暂时中止主程序的执行，转而去执行特定的中断服务程序（ISR），完成后再返回到主程序的中断点继续执行。

== 中断源与向量表 (Interrupt Sources and Vector Table)

标准的MCS-51微控制器有5个中断源。每个中断源都关联一个特定的中断请求标志位和一个固定的程序存储器地址，称为中断向量地址。当一个中断被CPU响应时，程序计数器PC会自动跳转到该中断的向量地址。

#table(
  columns: 4,
  align: (center, center, center, left),
  [*中断源*], [*中断请求标志*], [*触发条件 (典型)*], [*中断向量地址*],
  [外部中断0 (`INT0`)], [`IE0` (TCON.1)], [P3.2 (#overline(`INT0`)) 引脚产生边沿或电平信号], [`0003H`],
  [定时器0溢出 (`TF0`)], [`TF0` (TCON.5)], [定时器0计数溢出], [`000BH`],
  [外部中断1 (`INT1`)], [`IE1` (TCON.3)], [P3.3 (#overline(`INT1`)) 引脚产生边沿或电平信号], [`0013H`],
  [定时器1溢出 (`TF1`)], [`TF1` (TCON.7)], [定时器1计数溢出], [`001BH`],
  [串行口中断 (`SI`)], [`RI` (SCON.0) 或 `TI` (SCON.1)], [串行数据接收完成 (`RI`) 或发送完成 (`TI`)], [`0023H`],
)

通常，在中断向量地址处放置一条跳转指令（如 `LJMP ISR_Address`），将程序导向实际的中断服务程序。

== 中断控制与配置

中断系统的行为主要由三个特殊功能寄存器 (SFR) 控制：中断使能寄存器 `IE`，中断优先级寄存器 `IP`，以及定时器/计数器控制寄存器 `TCON` (部分位用于外部中断)。

=== 中断使能寄存器 `IE` (Interrupt Enable)

`IE` 寄存器 (地址 `0A8H`) 用于控制各个中断源是否被允许向CPU请求中断。它是可位寻址的。

#figure(
  table(
    columns: 8,
    align: center,
    [*位*], `7`, `6`, `5`, `4`, `3`, `2`, `1`, `0`,
    [*符号*], `EA`, `–`, `ES`, `ET1`, `EX1`, `ET0`, `EX0`, `–`,
    [*功能*], [全局中断使能], [保留], [串行口中断使能], [定时器1中断使能], [外部中断1使能], [定时器0中断使能], [外部中断0使能], [保留],
  ),
  caption: [中断使能寄存器 `IE` (0A8H)]
)

- `EA` (Global Interrupt Enable):
  - `EA = 1`: CPU开放总中断，允许各个已使能的中断源产生中断。
  - `EA = 0`: CPU屏蔽所有中断请求，任何中断源都不能产生中断。
- `ES` (Enable Serial Port Interrupt):
  - `ES = 1`: 允许串行口中断 (RI或TI)。
  - `ES = 0`: 禁止串行口中断。
- `ET1` (Enable Timer 1 Overflow Interrupt):
  - `ET1 = 1`: 允许定时器1溢出 (`TF1`) 中断。
  - `ET1 = 0`: 禁止定时器1溢出中断。
- `EX1` (Enable External Interrupt 1):
  - `EX1 = 1`: 允许外部中断1 (`INT1`)。
  - `EX1 = 0`: 禁止外部中断1。
- `ET0` (Enable Timer 0 Overflow Interrupt):
  - `ET0 = 1`: 允许定时器0溢出 (`TF0`) 中断。
  - `ET0 = 0`: 禁止定时器0溢出中断。
- `EX0` (Enable External Interrupt 0):
  - `EX0 = 1`: 允许外部中断0 (`INT0`)。
  - `EX0 = 0`: 禁止外部中断0。

*示例：使能全局中断、定时器0中断和外部中断0*
```asm
MOV IE, #10000011B  ; EA=1, ET0=1, EX0=1
; 或者使用位操作
; SETB EA
; SETB ET0
; SETB EX0
```

=== 中断优先级寄存器 `IP` (Interrupt Priority)

`IP` 寄存器 (地址 `0B8H`) 用于设置各个中断源的优先级。MCS-51支持两级中断优先级：高优先级和低优先级。它是可位寻址的。

#figure(
  table(
    columns: 8,
    align: center,
    [*位*], `7`, `6`, `5`, `4`, `3`, `2`, `1`, `0`,
    [*符号*], `–`, `–`, `PS`, `PT1`, `PX1`, `PT0`, `PX0`, `–`,
    [*功能*], [保留], [保留], [串行口中断优先级], [定时器1中断优先级], [外部中断1优先级], [定时器0中断优先级], [外部中断0优先级], [保留],
  ),
  caption: [中断优先级寄存器 `IP` (0B8H)]
)

- 将相应位置 `1` 可使其对应中断源为*高优先级*。
- 将相应位置 `0` 可使其对应中断源为*低优先级*。

*优先级处理规则：*
1.  高优先级的中断请求可以打断正在处理的低优先级中断服务程序。
2.  低优先级的中断请求不能打断正在处理的高优先级中断服务程序。
3.  任何中断（无论高低优先级）都不能打断正在处理的同级或更高优先级的中断服务程序。正在服务的同级中断请求需要等待当前ISR完成后才能响应。
4.  如果多个同优先级的中断请求同时发生，则按固定的“自然”查询顺序响应。此顺序为：
    外部中断0 (`INT0`) -> 定时器0 (`TF0`) -> 外部中断1 (`INT1`) -> 定时器1 (`TF1`) -> 串行口 (`SI`)。

*示例：设置定时器0为高优先级，串行口为高优先级，其他为低优先级*
```asm
MOV IP, #00000101B  ; PT0=1 (高), PS=1 (高)
; 或者使用位操作
; SETB PT0
; SETB PS
```

=== 定时器/计数器控制寄存器 `TCON` (Timer Control)

`TCON` 寄存器 (地址 `88H`) 中包含与中断相关的标志位和控制位，特别是针对外部中断。它是可位寻址的。

#figure(
  table(
    columns: 9,
    align: center,
    [*位*], `7`, `6`, `5`, `4`, `3`, `2`, `1`, `0`,
    [*符号*], `TF1`, `TR1`, `TF0`, `TR0`, `IE1`, `IT1`, `IE0`, `IT0`,
    [*功能*], [T1溢出标志], [T1运行控制], [T0溢出标志], [T0运行控制], [外部中断1标志], [外部中断1触发方式], [外部中断0标志], [外部中断0触发方式],
  ),
  caption: [定时器/计数器控制寄存器 `TCON` (88H) 中断相关位]
)

- `IT0` (TCON.0): 外部中断0 (`INT0`) 触发方式控制位。
  - `IT0 = 0`: 电平触发方式。只要 P3.2 (#overline(`INT0`)) 引脚为低电平，就可能触发中断。
  - `IT0 = 1`: 下降沿触发方式。P3.2 引脚上出现高电平到低电平的跳变时触发中断。
- `IE0` (TCON.1): 外部中断0 (`INT0`) 的中断请求标志位。
  - 当检测到有效的 `INT0` 信号（根据 `IT0` 设置）时，硬件自动将 `IE0` 置1。
  - 如果 `IT0=1` (边沿触发)，CPU响应中断后，硬件自动将 `IE0` 清0。
  - 如果 `IT0=0` (电平触发)，`IE0` 会一直保持为1直到外部低电平信号消失。此时，外部信号的撤除是清除中断请求的条件之一。
- `IT1` (TCON.2): 外部中断1 (`INT1`) 触发方式控制位。
  - `IT1 = 0`: 电平触发方式。只要 P3.3 (#overline(`INT1`)) 引脚为低电平，就可能触发中断。
  - `IT1 = 1`: 下降沿触发方式。P3.3 引脚上出现高电平到低电平的跳变时触发中断。
- `IE1` (TCON.3): 外部中断1 (`INT1`) 的中断请求标志位。
  - 行为类似于 `IE0`，但对应 `INT1` 和 `IT1`。
- `TF0` (TCON.5): 定时器0溢出中断标志。当定时器0从全1变为0时，硬件自动将 `TF0` 置1。CPU响应中断后，硬件自动将 `TF0` 清0。
- `TF1` (TCON.7): 定时器1溢出中断标志。当定时器1从全1变为0时，硬件自动将 `TF1` 置1。CPU响应中断后，硬件自动将 `TF1` 清0。

(注意：`TR0` 和 `TR1` 是定时器运行控制位，不是中断标志。)

== 中断标志与清除 (Interrupt Flags and Clearing)

每个中断源都有一个或多个中断请求标志。当中断条件满足时，相应的标志位由硬件置1。

-   定时器中断标志: `TF0` (TCON.5), `TF1` (TCON.7)。
    -   当定时器/计数器溢出时，硬件自动将相应的 `TFx` 位置1。
    -   当CPU响应 `TFx` 中断，自动跳转到对应的ISR向量地址后，硬件会自动将该 `TFx` 标志清0。
-   外部中断标志: `IE0` (TCON.1), `IE1` (TCON.3)。
    -   当外部中断引脚 (#overline(`INT0`), #overline(`INT1`)) 出现有效触发信号 (根据 `ITx` 设置) 时，硬件自动将相应的 `IEx` 位置1。
    -   对于*边沿触发* (`ITx = 1`)：CPU响应中断后，硬件会自动将该 `IEx` 标志清0。
    -   对于*电平触发* (`ITx = 0`)：`IEx` 标志将保持为1，只要外部引脚保持有效低电平。中断请求的撤销需要外部信号变为无效 (高电平)。在ISR中通常不需要手动清除 `IEx`，但必须确保外部信号已撤除，否则中断可能在 `RETI` 后立即再次触发。
-   串行口中断标志: `RI` (SCON.0), `TI` (SCON.1)。
    -   `RI` (Receive Interrupt): 串行口接收完一帧数据后，硬件自动将 `RI` 置1。
    -   `TI` (Transmit Interrupt): 串行口发送完一帧数据后，硬件自动将 `TI` 置1。
    -   *重要*：`RI` 和 `TI` 标志*必须由软件在中断服务程序中手动清0*。如果不在ISR中清除，中断将在 `RETI` 后立即再次发生。

== 中断服务程序 (Interrupt Service Routine - ISR)

当中断被CPU响应后，程序计数器 `PC` 会被加载中断向量地址，从而开始执行中断服务程序。

*ISR基本结构模板:*
```asm
; --- 中断向量定义 ---
ORG 0000H
LJMP MAIN_PROGRAM

ORG 000BH      ; 定时器0 (TF0) 的中断向量地址
LJMP TF0_ISR

ORG 0023H      ; 串行口 (RI/TI) 的中断向量地址
LJMP UART_ISR

; --- 主程序 ---
MAIN_PROGRAM:
    MOV SP, #60H       ; 初始化堆栈指针
    MOV IE, #10010010B ; 允许全局中断, 允许串行中断, 允许定时器0中断
    SETB TR0           ; 启动定时器0
    ; ... 其他主程序代码 ...
    SJMP $             ; 循环等待

; --- 定时器0中断服务程序 ---
TF0_ISR:
    PUSH ACC           ; 保存ACC到堆栈 (如果ISR中使用ACC)
    PUSH PSW           ; 保存PSW到堆栈 (如果ISR中影响标志位或切换寄存器组)
    ;
    ; -- ISR核心代码 --
    ; 例如: 重装定时器初值, 控制LED闪烁等
    MOV TH0, #HIGH_BYTE_RELOAD
    MOV TL0, #LOW_BYTE_RELOAD
    CPL P1.0           ; 翻转P1.0口线状态
    ;
    ; TF0硬件自动清零, 一般无需CLR TF0
    ;
    POP PSW            ; 恢复PSW (注意与PUSH顺序相反)
    POP ACC            ; 恢复ACC
    RETI               ; 从中断返回

; --- 串行口中断服务程序 ---
UART_ISR:
    PUSH ACC
    PUSH PSW
    ;
    IF RI = 1 THEN     ; 检查是否为接收中断
        CLR RI         ; *必须*软件清零RI标志
        MOV A, SBUF    ; 读取接收到的数据
        ; ... 处理接收数据 ...
    ENDIF
    ;
    IF TI = 1 THEN     ; 检查是否为发送中断
        CLR TI         ; *必须*软件清零TI标志
        ; ... 准备并发送下一个数据, 或标记发送完成 ...
    ENDIF
    ;
    POP PSW
    POP ACC
    RETI               ; 从中断返回
```

*关键点:*
1.  *上下文保存 (Context Saving)*: 如果ISR修改了任何主程序也会使用的寄存器 (如 `ACC`, `PSW`, `B`, `DPTR`, `R0-R7`)，则必须在ISR开始时将这些寄存器的内容压入堆栈 (`PUSH`)，并在ISR结束前从堆栈中恢复它们 (`POP`)。`POP` 的顺序必须与 `PUSH` 的顺序相反。
    -   如果ISR使用了不同的工作寄存器组 (通过修改 `PSW` 中的 `RS0/RS1`)，则 `R0-R7` 的保存可能不是必需的，但 `PSW` 本身仍需保存和恢复。
2.  *中断返回指令 `RETI`*: ISR必须以 `RETI` (Return from Interrupt) 指令结束。`RETI` 不仅将 `PC` 从堆栈中弹出以返回到主程序，还会恢复中断系统的内部逻辑状态，允许响应后续的同级或更高优先级的中断。使用 `RET` 代替 `RETI` 会导致中断系统工作不正常。
3.  *标志位清除*: 如前所述，`RI` 和 `TI` 必须由软件清除。`TFx` 和边沿触发的 `IEx` 由硬件自动清除。

通过合理配置和使用中断，MCS-51可以高效地处理异步事件，提高CPU的利用率。

= 定时器 (Timer/Counter)

MCS-51系列微控制器通常内置两个16位的定时器/计数器：定时器0 (T0) 和定时器1 (T1)。这些定时器/计数器非常灵活，是MCS-51强大功能的基础之一，广泛应用于定时、延时、事件计数、波形产生以及串行通信波特率发生等场合。

它们具有双重功能：
-   *定时器模式 (Timer Mode)*: 当作为定时器使用时，计数器在每个机器周期（即晶振频率的1/12）自动加1。这使其能够对内部时钟脉冲进行计数，从而实现精确的时间测量或延时。
-   *计数器模式 (Counter Mode)*: 当作为计数器使用时，计数器对施加到对应外部引脚 `T0` (P3.4) 或 `T1` (P3.5) 上的下降沿（高电平到低电平的跳变）进行计数。这使其能够记录外部事件发生的次数。

每个定时器/计数器主要由以下几部分组成：
-   两个8位特殊功能寄存器：`THx` (高字节) 和 `TLx` (低字节)，它们共同构成16位的计数寄存器。
-   工作模式控制：通过 `TMOD` 寄存器设置。
-   运行控制和状态标志：通过 `TCON` 寄存器控制和读取。
-   中断能力：每个定时器溢出时都可以产生中断请求 (TF0, TF1)，中断使能和优先级分别由 `IE` 和 `IP` 寄存器控制。

== 定时器/计数器控制寄存器

=== 定时器/计数器模式寄存器 `TMOD`

`TMOD` 寄存器 (地址 `89H`) 用于设置定时器0和定时器1的工作模式、定时/计数功能选择以及门控方式。`TMOD` *不是位寻址*的，因此必须通过字节操作 (如 `MOV TMOD, #value`) 来进行设置。

`TMOD` 寄存器的8位分为两个相同的4位字段：
-   高4位 (D7-D4) 用于设置 定时器1 (T1)。
-   低4位 (D3-D0) 用于设置 定时器0 (T0)。

#figure(
  table(
    columns: 9,
    align: center,
    [*位*], `D7`, `D6`, `D5`, `D4`, `D3`, `D2`, `D1`, `D0`,
    [*对应定时器*], table.cell(colspan: 4)[Timer 1], table.cell(colspan: 4)[Timer 0],
    [*符号*], `GATE`, `C/T#`, `M1`, `M0`, `GATE`, `C/T#`, `M1`, `M0`,
  ),
  caption: [TMOD 寄存器 (89H) 结构]
)

对于每个定时器的4位控制字段：
-   `GATE` (Gating Control): 门控位，控制定时器的启动方式。
    -   `GATE = 0`: 定时器/计数器的启停仅由其对应的运行控制位 `TRx` (在 `TCON` 寄存器中) 控制。即 `TRx=1` 启动，`TRx=0` 停止。这是最常用的方式。
    -   `GATE = 1`: 定时器/计数器的启停由 `TRx` 位和外部中断引脚 #overline(`INTx`) (#overline(`INT0`)即P3.2, #overline(`INT1`)即P3.3) 的电平共同控制。此时，需要 `TRx=1` *且* #overline(`INTx`) 引脚为高电平，定时器才会计数。常用于测量外部脉冲宽度。
-   `C/T#` (Counter/Timer Select): 计数器/定时器模式选择位。
    -   `C/T# = 0`: 选择为*定时器模式*。计数器在每个机器周期（晶振频率/12）加1。
    -   `C/T# = 1`: 选择为*计数器模式*。计数器对来自外部输入引脚 `Tx` (`T0`是P3.4, `T1`是P3.5) 的下降沿进行计数。
-   `M1`, `M0` (Mode Select): 工作模式选择位。这两位决定了定时器/计数器的位数和操作方式。

  #table(
    columns: 4,
    align: center,
    [*M1*], [*M0*], [*模式*], [*说明*],
    [0], [0], [0], [13位定时器/计数器 (TLx 5位, THx 8位)],
    [0], [1], [1], [16位定时器/计数器 (TLx 8位, THx 8位)],
    [1], [0], [2], [8位自动重装载定时器/计数器 (THx存重载值)],
    [1], [1], [3], [(T0) 双8位定时器/计数器; (T1) 停止计数],
  )

*TMOD 设置示例:*
```asm
; 例1: 设置 Timer 0 为模式1 (16位定时器), Timer 1 为模式2 (8位自动重装载定时器)
; T1: GATE=0, C/T=0, M1=1, M0=0  => 0010 (2H)
; T0: GATE=0, C/T=0, M1=0, M0=1  => 0001 (1H)
; TMOD = 00100001B = 21H
MOV TMOD, #21H

; 例2: 设置 Timer 0 为模式0 (13位计数器, 外部引脚T0计数), Timer 1 为模式1 (16位定时器, 硬件门控)
; T1: GATE=1, C/T=0, M1=0, M0=1  => 1001 (9H)
; T0: GATE=0, C/T=1, M1=0, M0=0  => 0100 (4H)
; TMOD = 10010100B = 94H
MOV TMOD, #94H
```

=== 定时器/计数器控制寄存器 `TCON`

`TCON` 寄存器 (地址 `88H`) 包含了定时器的运行控制位和溢出标志位，同时也包含了外部中断的标志和触发方式控制位 (已在中断系统部分详细介绍)。`TCON` 是*可位寻址*的。

#figure(
  table(
    columns: 9,
    align: center,
    [*位*], `7`, `6`, `5`, `4`, `3`, `2`, `1`, `0`,
    [*符号*], `TF1`, `TR1`, `TF0`, `TR0`, `IE1`, `IT1`, `IE0`, `IT0`,
    [*功能*], [T1溢出标志], [T1运行控制], [T0溢出标志], [T0运行控制], [外部中断1标志], [外部中断1触发方式], [外部中断0标志], [外部中断0触发方式],
  ),
  caption: [TCON 寄存器 (88H) 结构 (重点关注定时器相关位)]
)

定时器相关的位：
-   `TF1` (TCON.7): Timer 1 溢出标志位。
    -   当Timer 1 从全1 (FFFFH 或 FFH，取决于模式) 变为0时，硬件自动将 `TF1` 置1，并可触发Timer 1中断（如果中断已使能）。
    -   如果Timer 1中断被响应，硬件会自动清除 `TF1`。否则，`TF1` 必须由软件查询并清除 (e.g., `CLR TF1`)。
-   `TR1` (TCON.6): Timer 1 运行控制位。
    -   由软件置位 (`SETB TR1`) 来启动Timer 1。
    -   由软件清零 (`CLR TR1`) 来停止Timer 1。
-   `TF0` (TCON.5): Timer 0 溢出标志位。
    -   功能与 `TF1` 类似，但对应Timer 0。
-   `TR0` (TCON.4): Timer 0 运行控制位。
    -   功能与 `TR1` 类似，但对应Timer 0。

其余位 (`IE1`, `IT1`, `IE0`, `IT0`) 主要用于外部中断的控制和标志，已在“中断系统”章节中讨论。

== 定时器/计数器工作模式详解

=== 模式0 (13位定时器/计数器)

-   在此模式下，定时器/计数器表现为一个13位的计数器。
-   `TLx` 寄存器提供低5位 (TLx.4 - TLx.0)。
-   `THx` 寄存器提供高8位 (THx.7 - THx.0)。
-   当 `TLx` 的低5位计数溢出时，会向 `THx` 进位。当 `THx` 计数溢出时，相应的 `TFx` 标志位置1。
-   总计数值为 $2^13 = 8192$ 个计数周期。
-   此模式主要为了与早期的MCS-48系列微控制器兼容，在新的设计中较少使用。
-   *配置示例 (Timer 0, 模式0, 定时功能)*:
    ```asm
    MOV TMOD, #00H  ; T0模式0, GATE=0, C/T=0
    MOV TH0, #high_byte ; 初始值高8位
    MOV TL0, #low_5_bits; 初始值低5位 (高3位无效)
    SETB TR0        ; 启动Timer 0
    ```

=== 模式1 (16位定时器/计数器)

-   这是最常用的全16位定时器/计数器模式。
-   `THx` 和 `TLx` 共同组成一个16位的计数器，`THx` 为高8位，`TLx` 为低8位。
-   计数范围从 `0000H` 到 `FFFFH`。当计数从 `FFFFH` 溢出到 `0000H` 时，`TFx` 标志位置1。
-   最大计数值为 $2^{16} = 65536$ 个计数周期。

*定时值计算与示例 (Timer 0, 模式1, 定时1ms, 晶振11.0592MHz):*
1.  *机器周期计算*:
    一个机器周期 = $12 / f_("crystal")$。
    若 $f_("crystal") = 11.0592 "MHz"$, 则机器周期频率 = $11.0592 "MHz" / 12 = 0.9216 "MHz"$。
    每个计数所需时间 = $1 / (0.9216 "MHz") approx 1.085 "µs"$。
2.  *所需计数值计算*:
    目标延时 = $1 "ms" = 1000 "µs"$。
    所需计数值 N = $1000 "µs" / (1.085 "µs/count") approx 921.6 " counts"$. 更精确的计算应避免过早的近似，直接使用分数： $N = 1000 mu s times (11.0592 "MHz" / 12) = 1000 times 10^(-6) times (11.0592 times 10^6 / 12) = 1000 times 11.0592 / 12 = 921.6$. 实际编程中，通常选择一个晶振频率使得每个机器周期的时间更容易计算（如12MHz，1µs/机器周期）。
    对于 $12 "MHz"$ 晶振，机器周期频率 $1 "MHz"$, 每个计数 $1 "µs"$. N = $1000 "µs" / (1 "µs/count") = 1000 " counts"$.
3.  *重载值计算*:
    重载值 = $65536 - N$。
    若 N=1000 (使用12MHz晶振简化计算), 重载值 = $65536 - 1000 = 64536$.
    $64536$ (十进制) = `FC18H` (十六进制)。
    所以 `TH0 = 0FCH`, `TL0 = 18H`。

*初始化与启动代码 (Timer 0, Mode 1, 1ms延时 \@ 12MHz):*
```asm
MOV TMOD, #01H  ; Timer 0, Mode 1 (GATE=0, C/T=0, M1=0, M0=1 for T0)
MOV TH0, #0FCH  ; 装载TH0初值
MOV TL0, #18H   ; 装载TL0初值
SETB TR0        ; 启动Timer 0
; ... 等待TF0置1 (查询方式) 或等待中断 ...
; JNB TF0, $    ; 查询TF0标志
; CLR TR0        ; 停止Timer 0
; CLR TF0        ; 清除溢出标志
```

=== 模式2 (8位自动重装载定时器/计数器)

-   此模式下，`TLx` 作为8位计数器 (00H-FFH)，`THx` 则用于存放当 `TLx` 溢出时自动重新加载到 `TLx` 的值。
-   当 `TLx` 从 `FFH` 溢出到 `00H` 时，硬件自动将 `THx` 的内容复制到 `TLx`，同时将 `TFx` 标志位置1。
-   这使得定时器能够自动以固定的时间间隔产生中断或设置标志，非常适合产生周期性信号或作为串行通信的波特率发生器。
-   最大计数值为 $2^8 = 256$。
-   *配置示例 (Timer 1, 模式2, 定时功能, 重载值为 `0FDH`)*:
    ```asm
    MOV TMOD, #20H  ; Timer 1, Mode 2 (GATE=0, C/T=0, M1=1, M0=0 for T1)
    MOV TH1, #0FDH  ; 设置TH1的重载值
    MOV TL1, #0FDH  ; 通常也将初始值设为重载值，使其第一次计数周期也准确
    SETB TR1        ; 启动Timer 1
    ```
    每次 `TL1` 从 `0FDH` 计数到 `0FFH` (3个计数)，然后溢出，`TF1` 置1，`TL1` 自动重装为 `0FDH`。

=== 模式3 (仅适用于Timer 0 - 双8位定时器/计数器)

-   此模式下，Timer 0 被拆分为两个独立的8位定时器/计数器：
    -   `TL0`：作为一个8位定时器/计数器，使用 Timer 0 的控制位 `TR0` (TCON.4) 和中断标志 `TF0` (TCON.5)。它也使用 `TMOD` 中为 Timer 0 设置的 `GATE0` 和 `C/T0` 位。
    -   `TH0`：也作为一个8位定时器/计数器，但它*借用* Timer 1 的控制位 `TR1` (TCON.6) 和中断标志 `TF1` (TCON.7)。它也使用 `TMOD` 中为 Timer *1* (注意是T1的设置) 设置的 `GATE1` 和 `C/T#1` 位。
-   当 Timer 0 工作在模式3时：
    -   Timer 1 本身会停止计数 (其模式被强制为停止状态，其在TMOD中的M1,M0设置对它自身16位操作无效)。
    -   Timer 1 的中断 (`ET1` in `IE`) 实际上是由 `TH0` (作为独立8位定时器) 的溢出 (`TF1`) 触发。
-   这种模式在需要三个定时器/计数器且其中两个可以是8位的情况下非常有用。
    - TL0 使用 T0的 M0,M1 (固定为1,1代表模式3), C/T0\#, GATE0, TR0, TF0.
    - TH0 使用 T1的 C/T1\#, GATE1 (来自TMOD中T1的设置位), TR1, TF1.
-   *配置示例 (TL0作定时器, TH0作计数器)*:
    ```asm
    ; TMOD设置:
    ; Timer 0 部分: GATE0=0, C/T0#=0, M1_0=1, M0_0=1  (0011B for T0)
    ; Timer 1 部分 (被TH0借用其C/T#和GATE): GATE1=0, C/T1#=1 (M1_1,M0_1对TH0无效,可为00) (0100B for T1 field)
    ; TMOD = Timer1_field | Timer0_field = 0100 0011B = 43H
    MOV TMOD, #43H
    MOV TL0, #initial_value_TL0  ; TL0初值
    MOV TH0, #initial_value_TH0  ; TH0初值
    SETB TR0                     ; 启动TL0 (作为8位定时器)
    SETB TR1                     ; 启动TH0 (作为8位计数器, 借用TR1)
    ```

== 计数器功能 (Counter Functionality)

-   当 `TMOD` 寄存器中对应定时器的 `C/T#` 位被设置为1时，该单元工作在计数器模式。
-   计数器对外部输入引脚 `T0` (P3.4) 或 `T1` (P3.5) 上出现的*下降沿* (高电平到低电平的跳变) 进行计数。
-   在每个机器周期的S5P2期间，采样 `Tx` 引脚的电平。如果一个机器周期采样到高电平，而下一个机器周期采样到低电平，则认为发生了一次有效的下降沿，计数器加1。
-   由于采样机制，外部输入信号的每个高电平和低电平状态至少应保持一个完整的机器周期，才能确保被正确识别和计数。

== 定时器在串行通信中的应用

-   Timer 1 在模式2 (8位自动重装载) 下是MCS-51标准串行口在工作模式1和模式3时最常用的波特率发生器。
-   通过设置 `TH1` 的重载值，可以精确控制串行通信的波特率。具体的计算方法将在串行口章节详细介绍。
-   Timer 0 也可以用于产生波特率，但Timer 1更为普遍。

= 人机交互接口 (Human-Machine Interface)

本章节讨论MCS-51微控制器与常见人机交互设备（如键盘、数码管显示器）的接口技术。这些设备是用户与嵌入式系统进行信息交换的重要手段。

== 键盘接口 (Keyboard Interface)

键盘是微控制器系统中常用的输入设备，允许用户输入指令、数据或进行选择操作。简单的独立按键接口和较复杂的矩阵键盘接口是两种常见的形式。

=== 按键去抖动 (Debouncing)
由于按键的机械特性，在按下和释放的瞬间，其内部触点会经历一个短暂的、快速的多次接通与断开的过程，这被称为“抖动”(bouncing)。如果微控制器直接读取此时的电平状态，可能会将一次按键动作误判为多次。因此，必须采取“去抖动”措施。

- *硬件去抖 (Hardware Debouncing)*:
  通过外部硬件电路消除抖动。常用的方法包括使用RS触发器（例如，由两个与非门交叉耦合构成）或单稳态触发器（如74HC123）。当按键状态改变时，触发器改变状态并保持，直到下一次稳定的按键动作。专用去抖芯片（如MAX6816/7/8）也提供了集成解决方案。硬件去抖效果好，不占用CPU时间，但会增加电路复杂度和成本。

- *软件去抖 (Software Debouncing)*:
  通过程序延时和多次采样来确认按键状态。基本思路是：
  1. 检测到按键引脚电平变化（例如，从高到低表示按下）。
  2. 不立即确认，而是启动一个短延时（通常为10ms ~ 20ms）。
  3. 延时结束后，再次读取按键引脚电平。
  4. 如果电平与第一次检测到的变化后状态一致，则确认为一次有效的按键动作。
  对于按键释放的检测，逻辑类似。软件去抖成本低，灵活性高，是MCS-51等资源受限系统中常用的方法。

(后续可补充键盘扫描、按键编码、矩阵键盘接口等更复杂的内容，目前主要介绍基础概念。)

== 数码管显示接口 (Digital Display Tube Interface)

数码管，特指LED七段数码管，是微控制器应用中广泛使用的显示器件，用于直观地显示数字或部分字母及符号。

- *类型*:
  - *共阴极数码管 (Common Cathode - CC)*: 数码管内部所有LED段（a, b, c, d, e, f, g, dp）的阴极连接到同一个公共引脚 (COM)。此COM引脚通常接地。要点亮某一段，其对应的段选线（如P2.0控制a段）需输出高电平，使电流从段选线流向COM端。
  - *共阳极数码管 (Common Anode - CA)*: 数码管内部所有LED段的阳极连接到同一个公共引脚 (COM)。此COM引脚通常接电源正极 (VCC)。要点亮某一段，其对应的段选线需输出低电平，使电流从COM端流向段选线。

- *驱动*:
  - *静态驱动*: 每个数码管的每一段都由微控制器的一个I/O引脚独立控制（或通过锁存器/驱动器）。适用于少量数码管的显示，接线简单但占用I/O口多。
  - *动态扫描驱动*: 利用人眼的视觉暂留效应。多位数码管的同名段（如所有数码管的a段）并联在一起，由一组I/O口控制；各位数码管的公共端（COM）则由另一组I/O口分别控制。CPU分时轮流选通每一位数码管的公共端，并同时输出该位对应的段码。只要扫描速度足够快（通常>50Hz），人眼看到的就是稳定无闪烁的显示。这种方式大大节省了I/O口线。
  - *限流电阻*: 为保护LED段不因电流过大而烧毁，每段（静态驱动）或每个公共端驱动线路（动态扫描，视具体电路而定）通常需要串联一个限流电阻。

(单个7段数码管的直接驱动示例已在“实践汇编范例”中给出。后续可补充多位数码管的动态扫描驱动程序设计、专用驱动芯片如74HC595或MAX7219的应用等内容。)

= 串行口 (Serial Port / UART)

MCS-51微控制器内置一个可编程的全双工串行通信接口，通常称为UART (Universal Asynchronous Receiver/Transmitter)。它可以在微控制器与外部设备（如PC、其他微控制器、传感器、串行存储器等）之间实现串行数据交换。

== 异步串行通信基础

异步通信意味着发送和接收设备不需要共享同一个时钟信号。数据的同步是通过特定的帧格式实现的：
-   *起始位 (Start Bit)*: 标志一个数据帧的开始，通常是一个从高到低的电平跳变。
-   *数据位 (Data Bits)*: 通常是7位或8位，表示实际传输的数据，一般低位在前 (LSB first)。MCS-51的串行口主要支持8位数据。
-   *奇偶校验位 (Parity Bit - Optional)*: 可选的错误检测位。可以是奇校验、偶校验或无校验。MCS-51在9位模式（模式2和3）下，第9位可以作为奇偶校验位或用于其他目的。
-   *停止位 (Stop Bit(s))*: 标志一个数据帧的结束，通常是一个或两个高电平周期。MCS-51在不同模式下发送1个停止位。

由于是全双工，MCS-51可以通过 `RXD` (Receive Data, P3.0) 引脚接收数据的同时，通过 `TXD` (Transmit Data, P3.1) 引脚发送数据。

== 串行口控制寄存器

=== 串行控制寄存器 `SCON` (Serial Control)

`SCON` 寄存器 (地址 `98H`) 用于配置串行口的工作模式、允许接收，并包含发送和接收中断标志。它是*可位寻址*的。

#figure(
  table(
    columns: 9,
    align: center,
    [*位*], `7`, `6`, `5`, `4`, `3`, `2`, `1`, `0`,
    [*符号*], `SM0/FE`, `SM1`, `SM2`, `REN`, `TB8`, `RB8`, `TI`, `RI`,
    [*说明*], [模式位0/帧错误], [模式位1], [多机通信使能], [接收使能], [发送第9位], [接收第9位], [发送中断标志], [接收中断标志],
  ),
  caption: [SCON 寄存器 (98H) 结构]
)

-   `SM0/FE` (SCON.7): 串行口工作模式选择位0。在模式0中，此位也用作 `FE` (Framing Error) 标志，当接收到的停止位无效时，硬件会置位 `FE`。在其他模式下，它仅作为 `SM0`。
-   `SM1` (SCON.6): 串行口工作模式选择位1。
    `SM0` 和 `SM1` 共同决定串行口的工作模式：
    #table(
      columns: 5,
      align: center,
      [*SM0*], [*SM1*], [*模式*], [*说明*], [*波特率*],
      [0], [0], [0], [8位同步移位寄存器], [固定 (f_osc/12)],
      [0], [1], [1], [8位UART，波特率可变 (由定时器1决定)], [可变],
      [1], [0], [2], [9位UART，波特率固定 (f_osc/32 或 f_osc/64)], [固定],
      [1], [1], [3], [9位UART，波特率可变 (由定时器1决定)], [可变],
    )
-   `SM2` (SCON.5): 多机通信使能位。
    -   在模式2和3中，若 `SM2=1`，则只有当接收到的第9位数据 (`RB8`) 为1时，`RI` 标志才会被激活，CPU才会响应中断。这用于实现多机通信时的地址检测。
    -   在模式1中，若 `SM2=1`，则只有接收到有效的停止位时，`RI` 才会被激活。
    -   在模式0中，`SM2` 必须为0。
-   `REN` (SCON.4): 接收使能位。
    -   `REN = 1`: 允许串行口接收数据。
    -   `REN = 0`: 禁止串行口接收数据。
-   `TB8` (SCON.3): 发送数据第9位。在模式2和3 (9位UART模式) 中，这是要发送的第9位数据。可以由软件置位或清零。
-   `RB8` (SCON.2): 接收数据第9位。在模式2和3中，这是接收到的第9位数据。在模式1中，如果 `SM2=0`，`RB8` 是接收到的停止位。
-   `TI` (SCON.1): 发送中断标志位。
    -   在模式0中，当8位数据发送完成时，由硬件置1。
    -   在其他模式中，当一帧数据（包括起始位、数据位、可能的第9位、停止位）的发送启动后 (通常是停止位开始发送的时刻)，由硬件置1。
    -   *必须由软件清零 `TI`*。
-   `RI` (SCON.0): 接收中断标志位。
    -   在模式0中，当8位数据接收完成时，由硬件置1。
    -   在其他模式中，当一帧数据（包括起始位、数据位、可能的第9位、停止位）的接收完成时 (通常是停止位的中间时刻采样到有效电平)，由硬件置1。
    -   *必须由软件清零 `RI`*。

=== 电源控制寄存器 `PCON` (Power Control) - SMOD位

`PCON` 寄存器 (地址 `87H`) 主要用于电源管理，但其最高位 `PCON.7` 对串行口的波特率有影响。

#figure(
  table(
    columns: 9,
    align: center,
    [*位*], `7`, `6`, `5`, `4`, `3`, `2`, `1`, `0`,
    [*符号*], `SMOD`, `SMOD0(52系列)`, `POF(52系列)`, `GF1`, `GF0`, `PD`, `IDL`, `(保留或特定型号功能)`,
  ),
  caption: [PCON 寄存器 (87H) 结构 (SMOD位与串行口相关)]
)
(注：PCON的其余位功能可能因具体51型号而异，如`SMOD0` `POF` `GF1` `GF0`等。)

-   `SMOD` (PCON.7): 串行口波特率倍增位。
    -   当 `SMOD = 0` (复位后的默认值)，在串行口模式1、2、3中，使用标准的波特率计算公式。
    -   当 `SMOD = 1`，在串行口模式1、2、3中，如果使用定时器1作为波特率发生器，则波特率加倍。
    -   `SMOD` 对模式0的波特率没有影响。

== 串行口工作模式详解

=== 模式0 (8位同步移位寄存器)

-   数据格式：发送或接收8位数据。
-   同步方式：`RXD` (P3.0) 引脚用于串行数据输入/输出，`TXD` (P3.1) 引脚输出同步的移位脉冲（时钟）。
-   波特率：固定为系统时钟频率的1/12，即 $f_("osc") / 12$。
-   `SCON` 设置: `SM0=0, SM1=0` (即 `SCON = xx00xxxxB`)。`REN=1` 允许接收。
-   用途：主要用于扩展I/O口，例如连接串入并出或串入串出的移位寄存器 (如74HC164, 74HC595)。
-   数据传输：
    -   发送：数据写入 `SBUF` 后开始发送。`TI` 在8位数据发送完后置1。
    -   接收：`REN=1` 后，由外部时钟在 `TXD` 上驱动，数据从 `RXD` 输入。`RI` 在8位数据接收完后置1。

=== 模式1 (8位UART，波特率可变)

-   数据格式：发送或接收10位数据帧：1位起始位 (低电平)，8位数据位 (LSB在前)，1位停止位 (高电平)。
-   波特率：由定时器1的溢出率决定。
    公式: $"Baud Rate" = (2^"SMOD" / 32) times "Timer 1 Overflow Rate"$
    当定时器1工作在模式2 (8位自动重载模式) 时，Timer 1 Overflow Rate = $f_("osc") / (12 times (256 - "TH1"))$
    所以， $"Baud Rate" = (2^"SMOD" / 32) times (f_("osc") / (12 times (256 - "TH1")))$
    由此可得 `TH1` 的计算公式: $"TH1" = 256 - ( (2^"SMOD" times f_("osc")) / (384 times "Baud Rate") )$
-   `SCON` 设置: `SM0=0, SM1=1` (即 `SCON = 01xxxxxxB`, 通常设为 `SCON = 50H` 来使能接收 `REN=1` 且 `SM2=0`)。
-   这是最常用的异步串行通信模式。

*示例：设置波特率为 9600 bps，晶振 $f_("osc") = 11.0592 "MHz"$*
1.  选择 `SMOD` 值。假设 `SMOD = 1` (波特率加倍)。
2.  计算 `TH1` 值:
    $"TH1" = 256 - ( (2^1 times 11.0592 times 10^6) / (384 times 9600) )$
    $"TH1" = 256 - ( (2 times 11059200) / 3686400 )$
    $"TH1" = 256 - ( 22118400 / 3686400 )$
    $"TH1" = 256 - 6 = 250 = "0FAH"$
3.  初始化代码:
    ```asm
    MOV TMOD, #20H  ; Timer 1, Mode 2 (8-bit auto-reload)
    MOV PCON, PCON OR #80H ; Set SMOD=1 (PCON.7)
    ; 或先读PCON，再OR，再写回，以防影响PCON其他位 (如果这些位被使用)
    ; MOV A, PCON
    ; ORL A, #80H
    ; MOV PCON, A
    MOV TH1, #0FAH  ; Reload value for 9600 baud with SMOD=1
    MOV TL1, #0FAH  ; Initial value
    MOV SCON, #50H  ; Mode 1, REN=1 (SM0=0,SM1=1,SM2=0,REN=1)
    SETB TR1        ; Start Timer 1 (for baud rate generation)
    SETB ES         ; Enable Serial Interrupt (if using interrupts)
    SETB EA         ; Enable Global Interrupt (if using interrupts)
    ```
    如果 `SMOD = 0` (默认)，则 $"TH1" = 256 - 3 = 253 = "0FDH"$。

=== 模式2 (9位UART，波特率固定)

-   数据格式：发送或接收11位数据帧：1位起始位，8位数据位 (LSB在前)，1位可编程的第9位数据 (`TB8`发送, `RB8`接收)，1位停止位。
-   波特率：固定，取决于 `SMOD` 位。
    -   若 `SMOD = 1`，波特率 = $f_("osc") / 32$。
    -   若 `SMOD = 0`，波特率 = $f_("osc") / 64$。
-   `SCON` 设置: `SM0=1, SM1=0` (即 `SCON = 10xxxxxxB`, e.g., `SCON = D0H` for `REN=1, SM2=1, TB8=1`)。
-   用途：常用于多机通信，第9位数据可作为地址/数据标志。

=== 模式3 (9位UART，波特率可变)

-   数据格式：与模式2相同 (11位帧)。
-   波特率：与模式1相同，由定时器1的溢出率决定。计算公式同模式1。
-   `SCON` 设置: `SM0=1, SM1=1` (即 `SCON = 11xxxxxxB`, e.g., `SCON = F0H` for `REN=1, SM2=1, TB8=1`)。
-   用途：结合了模式1的波特率灵活性和模式2的9位数据能力。

== 数据缓冲器 `SBUF`

-   串行口数据缓冲器 `SBUF` (地址 `99H`) 在物理上是两个独立的寄存器：一个是发送缓冲器 (只写)，另一个是接收缓冲器 (只读)。
-   发送数据: `MOV SBUF, A` — 将累加器 `A` 中的数据写入发送缓冲器，串行口会自动开始发送。
-   接收数据: `MOV A, SBUF` — 从接收缓冲器读取已接收到的数据到累加器 `A`。

== 串行通信编程

=== 初始化步骤 (以模式1为例)

```asm
INIT_SERIAL:
    MOV TMOD, #20H     ; Timer 1, Mode 2 (8-bit auto-reload) for baud rate
    MOV A, PCON        ; Read PCON
    ORL A, #80H        ; Set SMOD=1 (PCON.7) to double baud rate
    MOV PCON, A        ; Write back to PCON
    MOV TH1, #0FAH     ; For 9600 baud at 11.0592MHz with SMOD=1
    MOV TL1, #0FAH     ; Initial value for TL1
    MOV SCON, #50H     ; Serial Mode 1 (8-bit UART), REN=1 (Receive Enable)
    SETB TR1           ; Start Timer 1
    ; CLR TI           ; Clear Transmit Interrupt flag (good practice)
    ; CLR RI           ; Clear Receive Interrupt flag (good practice)
    ; SETB ES          ; Enable Serial Port Interrupt (if using interrupts)
    ; SETB EA          ; Enable Global Interrupt (if using interrupts)
    RET
```

=== 发送单个字符 (查询方式)

```asm
SEND_CHAR_POLL:
    ; Assume character to send is in ACC
    MOV SBUF, A        ; Load data into SBUF, transmission starts
WAIT_TI:
    JNB TI, WAIT_TI    ; Wait for Transmit Interrupt flag (TI) to be set
    CLR TI             ; Clear TI flag for next transmission
    RET
```

=== 接收单个字符 (查询方式)

```asm
RECEIVE_CHAR_POLL:
WAIT_RI:
    JNB RI, WAIT_RI    ; Wait for Receive Interrupt flag (RI) to be set
    MOV A, SBUF        ; Read received data from SBUF
    CLR RI             ; Clear RI flag for next reception
    ; ACC now holds the received character
    RET
```

=== 中断方式编程结构

```asm
; --- In Interrupt Vector Table ---
ORG 0023H          ; Serial Port Interrupt Vector
LJMP SERIAL_ISR

; --- Main Program Setup ---
; CALL INIT_SERIAL     ; Initialize serial port and Timer 1
; MOV IE, #10010000B ; Enable EA and ES (Serial Interrupt)

; --- Serial Interrupt Service Routine ---
SERIAL_ISR:
    PUSH ACC           ; Save context
    PUSH PSW

    IF RI = 1 THEN     ; Check if Receive Interrupt
        CLR RI         ; Clear RI flag *first*
        MOV A, SBUF    ; Get received char
        ; ... process received char in A ...
        ; Example: MOV P1, A ; Display on P1
    ENDIF

    IF TI = 1 THEN     ; Check if Transmit Interrupt
        CLR TI         ; Clear TI flag
        ; ... code to send next char if any, or set a flag for completion ...
        ; Example: (if sending a string)
        ; CJNE R0, #0, SEND_NEXT_IN_ISR ; Assuming R0 points to string and is not 0
        ; SJMP ISR_EXIT
        ; SEND_NEXT_IN_ISR:
        ;   MOV A, @R0
        ;   INC R0
        ;   MOV SBUF, A
    ENDIF

ISR_EXIT:
    POP PSW            ; Restore context
    POP ACC
    RETI
```

== 多机通信 (`SM2` 位)

-   在模式2或模式3下，如果 `SM2` 位 (SCON.5) 被置1，则串行中断标志 `RI` 只有在接收到的第9位数据 (`RB8`) 为1时才会被激活。
-   这允许在多微控制器系统中实现一种简单的地址检测机制：
    1.  主机发送一个地址字节，并将第9位置1 (`TB8=1`)。
    2.  所有从机都设置为 `SM2=1`。只有地址匹配的从机（通过比较接收到的8位数据与自身地址）会清除其 `SM2` 位，准备接收后续的数据字节。
    3.  主机随后发送数据字节，并将第9位置0 (`TB8=0`)。
    4.  只有那些清除了 `SM2` 位的从机才会因 `RB8=0` 而不置位 `RI` (从而不被数据打扰，除非 `SM2` 被清零，此时 `RI` 会正常响应)。
        更准确地说：当 `SM2=1` 时，如果 `RB8=0`，则 `RI` 不会激活，CPU不会被中断。如果 `RB8=1` (通常是地址帧)，`RI` 会激活，ISR可以检查地址。如果地址匹配，ISR中可以清零`SM2`，这样后续的数据帧(通常`RB8=0`)就会激活`RI`。
-   这种机制使得主机可以有效地对特定从机进行寻址和数据传输，而其他从机则忽略不相关的数据。

= 模拟接口 (Analog Interface)

标准MCS-51系列微控制器是纯数字器件，其CPU和I/O端口只能处理和产生高低电平（逻辑1和0）的数字信号。然而，现实世界中的许多物理量，如温度、湿度、光照强度、声音、压力、速度等，都是连续变化的模拟信号。为了使微控制器能够感知和影响这些模拟量，就需要通过特定的接口电路在数字域和模拟域之间进行转换。这主要通过模数转换器 (ADC) 和数模转换器 (DAC) 来实现。

== 模拟-数字转换器 (ADC - Analog-to-Digital Converter)

*概念 (Concept):*
ADC是一种将连续变化的模拟电压或电流信号转换为微控制器可以读取和处理的离散数字值的电子器件。例如，传感器输出的0-5V模拟电压可以被ADC转换为一个8位的数字（0-255）。

*主要参数 (Key Parameters - Briefly):*
-   *分辨率 (Resolution)*: ADC能够区分的最小模拟电压变化，通常用位数表示。例如，一个8位ADC可以将输入范围分为 $2^8 = 256$ 个离散的数字级别。10位ADC则有 $2^{10} = 1024$ 级，分辨率更高。
-   *转换时间 (Conversion Time)*: ADC完成一次从模拟输入到数字输出的转换所需的时间。这个时间限制了ADC可以处理的最高信号频率。
-   *输入电压范围 (Input Voltage Range)*: ADC能够正确转换的模拟输入电压的上限和下限，例如0V到5V，或-2.5V到+2.5V。通常需要一个参考电压 (Vref) 来定义此范围。

*与MCS-51的接口 (Interfacing - General Idea):*
MCS-51本身不集成ADC，因此需要外接ADC芯片。
-   *常用ADC芯片*:
    -   `ADC0804`: 一款经典的8位并行输出ADC，具有单个模拟输入通道，接口相对简单。
    -   `ADC0808`/`ADC0809`: 8位ADC，但具有8个模拟输入通道，可以通过地址线选择其中一个通道进行转换。
-   *控制信号 (Control Signals)*: MCU通过I/O口线向ADC发送控制信号：
    -   `CS` (Chip Select): 片选信号，用于选中ADC芯片。
    -   `WR` (Write) / `SC` (Start Conversion): 启动转换信号。MCU发出一个脉冲（如低到高再到低）给此引脚以启动一次新的A/D转换。
    -   `RD` (Read) / `OE` (Output Enable): 读取数据/输出使能信号。MCU发出一个脉冲（或置于有效电平）以使能ADC的数据输出缓冲器，从而将转换后的数字量放到数据总线上。
-   *状态信号 (Status Signals)*: ADC向MCU反馈转换状态：
    -   `INTR` (Interrupt Request) / `EOC` (End of Conversion): 转换结束信号。当ADC完成转换后，此引脚会发出一个信号（如从高到低跳变或变为某个电平），通知MCU数据已准备好可以读取。MCU可以查询此引脚或将其连接到中断输入。
-   *数据传输 (Data Transfer)*: 转换后的数字量通过ADC的数据输出引脚 (D0-D7对于8位ADC) 并行输出，MCU通过一个或多个I/O端口读取这些数据。

*简化的接口框图描述:*
```
Analog Signal ----> | ADC Chip | ----> Digital Data (to MCU I/O Port Px)
                    ----------
MCU I/O (Control) ----> WR/SC (to ADC)
MCU I/O (Control) ----> RD/OE (to ADC)
MCU I/O (Status) <---- INTR/EOC (from ADC)
```

*ADC0804读取概念步骤:*
```asm
; 假设P1口连接ADC0804数据线 D0-D7
; P2.0 连接 /CS (低有效)
; P2.1 连接 /RD (低有效)
; P2.2 连接 /WR (低有效)
; P2.3 连接 INTR (高表示转换结束)

READ_ADC0804:
    CLR  P2.0        ; /CS = 0, 选中ADC0804
    SETB P2.2        ; /WR = 1
    CLR  P2.2        ; 发出 /WR 下降沿脉冲启动转换
    SETB P2.2        ; /WR = 1

WAIT_EOC:
    JB   P2.3, DATA_READY ; 等待INTR变高 (转换结束)
    SJMP WAIT_EOC

DATA_READY:
    SETB P2.1        ; /RD = 1
    CLR  P2.1        ; /RD = 0, 使能数据输出
    MOV  A, P1         ; 从P1口读取转换结果
    SETB P2.1        ; /RD = 1, 禁止数据输出
    SETB P2.0        ; /CS = 1, 取消选中
    ; A中为ADC转换结果
    RET
```

== 数字-模拟转换器 (DAC - Digital-to-Analog Converter)

*概念 (Concept):*
DAC是一种将微控制器输出的数字量（二进制码）转换为成比例的模拟电压或电流信号的电子器件。这使得MCU能够控制模拟设备，如电机速度、音频信号幅度、LED亮度等。

*主要参数 (Key Parameters - Briefly):*
-   *分辨率 (Resolution)*: DAC能够产生的模拟输出电平数，通常用位数表示。例如，一个8位DAC可以将数字0-255映射到 $2^8 = 256$ 个不同的模拟输出级别。
-   *建立时间 (Settling Time)*: 当数字输入改变后，DAC输出达到并稳定在其最终模拟值所需的时间。
-   *输出范围 (Output Range)*: DAC能够产生的模拟电压或电流的范围，如0-5V电压输出或0-2mA电流输出。

*与MCS-51的接口 (Interfacing - General Idea):*
与ADC类似，DAC通常也是外部芯片。
-   *常用DAC芯片*:
    -   `DAC0808`: 一款经典的8位并行输入DAC，输出为电流。通常需要外接一个运算放大器将电流转换为电压。
    -   `DAC0832`: 8位并行输入DAC，具有双缓冲输入锁存器，更易于与微处理器接口，可配置为单缓冲或双缓冲模式。
-   *数据传输 (Data Transfer)*: MCU通过一个或多个I/O端口将要转换的数字量并行写入DAC的数据输入引脚 (D0-D7对于8位DAC)。
-   *控制信号 (Control Signals)*:
    -   `CS` (Chip Select): 片选信号。
    -   `WR` (Write): 写入信号。MCU发出脉冲，将数据总线上的数据锁存到DAC的输入寄存器。
    -   `LE` (Latch Enable) / `XFER`: 锁存使能/数据传输控制。在某些DAC（如DAC0832）中，可能需要额外的信号来将输入寄存器的数据传输到DAC寄存器以更新模拟输出。

*简化的接口框图描述:*
```
MCU I/O Port Px (Digital Data) ----> | DAC Chip | ----> Analog Signal Output
                                     ----------
MCU I/O (Control) ----> WR/LE (to DAC)
```

*DAC0808/0832输出概念步骤:*
```asm
; 假设P1口连接DAC数据线 D0-D7
; P2.0 连接 /CS (DAC0832, 低有效)
; P2.1 连接 /WR1 (DAC0832, 低有效, 用于锁存输入数据)
; (DAC0808可能只需要数据输入和电流转电压电路)

WRITE_DAC:
    ; 数字量在累加器A中
    ; 对于DAC0832
    CLR  P2.0        ; /CS = 0, 选中DAC
    MOV  P1, A         ; 将数字量输出到P1口 (连接DAC数据输入)
    CLR  P2.1        ; /WR1 = 0, 开始写入数据到DAC输入锁存器
    SETB P2.1        ; /WR1 = 1, 完成写入, 数据被锁存
    ; (DAC0832可能还需要ILE,/XFER信号来更新输出,取决于配置)
    SETB P2.0        ; /CS = 1, 取消选中 (如果需要)

    ; 对于DAC0808, 通常数据直接送到D0-D7, 输出电流即改变
    ; MOV P1, A      ; 将数据送P1 (连接DAC0808数据输入)
    ; 模拟输出电流会相应改变, 外接运放将其转为电压
    RET
```

== 总结

虽然MCS-51本身没有集成的模拟处理能力，但通过外接ADC和DAC芯片，它可以非常有效地与模拟世界进行交互。ADC将模拟世界的状态“翻译”给MCU，而DAC则让MCU能够以模拟方式“行动”或“表达”。选择合适的ADC/DAC芯片并正确设计接口电路是实现这些功能的关键。

= 汇编语言编程规范与技巧 \ (Assembly Language Programming Guidelines and Tips)

良好的编程规范对于编写清晰、可读、可维护和易于调试的汇编语言程序至关重要。即使在资源受限的微控制器如MCS-51上，遵循一定的规范和技巧也能大大提高开发效率和代码质量。

== 结构化汇编代码 (Structuring Assembly Code)

=== 标号 (Labels)
-   *意义明确*: 使用有意义的标号来标记地址、子程序入口和循环等。例如，`DELAY_LOOP`, `CALCULATE_CHECKSUM`, `MAIN_INIT` 比 `L1`, `L2`, `SUB1` 更具可读性。
-   *风格一致*: 保持标号风格的一致性，例如全部大写 (`MAIN_LOOP`) 或下划线分隔的小写 (`delay_loop`)。

=== 注释 (Comments)
注释是汇编代码中不可或缺的部分，因为汇编指令本身提供的上下文信息较少。
-   *无处不在*: 为重要的指令或代码块添加注释。对于复杂的逻辑，注释尤其重要。
-   *解释“为何”而非“何事”*: 指令本身（如 `MOV A, R0`）已经说明了“何事”（将R0内容送A）。注释应侧重于解释“为何”要这么做，即代码的意图和逻辑。
-   *描述资源*: 注释变量的用途、子程序传递的参数（例如，通过哪个寄存器或内存地址传递）、子程序的返回值以及哪些寄存器或标志位可能被修改。
-   *示例*:
    ```asm
    ; --- Delay Subroutine ---
    ; Input: None (or specify if registers like R0, R1 are used for parameters)
    ; Output: None
    ; Modifies: R6, R7 (registers used by the delay loop)
    ; Purpose: Creates a software-based time delay.
    ;          The exact delay duration depends on R6, R7 values and crystal frequency.
    DELAY:
        MOV R6, #100   ; Load outer loop counter value
    DELAY_OUTER_LOOP:
        MOV R7, #200   ; Load inner loop counter value
    DELAY_INNER_LOOP:
        DJNZ R7, DELAY_INNER_LOOP ; Decrement R7; if not zero, loop again (inner loop)
        DJNZ R6, DELAY_OUTER_LOOP ; Decrement R6; if not zero, loop again (outer loop)
        RET
    ```

=== 模块化 (Subroutines)
-   *分解任务*: 将复杂的程序分解为多个小的、功能单一的子程序。
-   *明确功能*: 每个子程序应有一个清晰、明确的用途。
-   *调用与返回*: 使用 `ACALL` (2KB范围内) 或 `LCALL` (64KB范围内) 指令调用子程序，子程序以 `RET` 指令返回。
-   *接口文档化*: 清晰注释子程序的输入参数（如何传递）、输出结果（如何返回）以及它会修改哪些寄存器或标志位。

=== 数据定义 (Data Definition)
-   *程序存储器中的数据*: 使用 `DB` (Define Byte) 定义字节大小的常数或数据表，使用 `DW` (Define Word) 定义字（16位）大小的常数或地址指针。
    ```asm
    MY_MESSAGE: DB 'Error!', 00H  ; Null-terminated string in ROM
    VALUE_TABLE: DB 12H, 34H, 56H
    POINTER_TO_TABLE: DW MY_MESSAGE
    ```
-   *RAM中变量*: MCS-51汇编中，内部RAM变量通常通过其直接地址（如 `30H`）或符号（通过 `EQU` 定义）来隐式“定义”和使用。一些高级汇编器可能支持类似 `DS` (Define Storage) 的伪指令来为RAM变量赋予符号名称并由汇编器分配地址，但这通常是符号表层面的操作，并不直接在HEX文件中保留空间。

== 常用汇编器伪指令 (Common Assembler Directives)

伪指令是给汇编器看的指令，用于指导汇编过程，不直接转换为机器码。
-   `ORG` (Origin): 设置当前指令或数据的起始地址（偏移地址）。
    -   示例: `ORG 0000H` (程序从ROM的0000H开始), `ORG 0100H` (后续代码从ROM的0100H开始)。
-   `EQU` (Equate): 将一个常量值赋予一个符号（标号）。该符号后续可在代码中代替此常量，增强可读性和可维护性。`EQU`不分配存储空间。
    -   示例: `DELAY_VALUE EQU 250`, `USER_PORT EQU P1`。
-   `DB` (Define Byte): 在程序存储器 (ROM) 中定义一个或多个字节数据。
    -   示例: `DATA_BYTE: DB 0F5H`, `STRING: DB 'Hello', 0`.
-   `DW` (Define Word): 在程序存储器 (ROM) 中定义一个或多个字 (16位) 数据。对于MCS-51，通常低字节在前，高字节在后。
    -   示例: `ADDR_PTR: DW STRING_ADDR`.
-   `END`: 标记源程序的结束。汇编器会停止处理此指令之后的内容。
-   `BIT` (Define Bit Address - 某些汇编器支持): 为可位寻址的位赋予一个符号名称。
    -   示例: `LED_PIN BIT P1.0`, `FLAG_CARRY BIT PSW.7`.

== MCS-51 编程技巧 (Programming Tips)

-   *寄存器使用*:
    -   善用工作寄存器组 (通过 `PSW` 的 `RS0`, `RS1` 位选择)。在中断服务程序 (ISR) 中切换寄存器组可以快速保存和恢复R0-R7，减少 `PUSH`/`POP` 操作，提高中断响应速度。
    -   累加器 `A` 是核心寄存器，许多算术、逻辑操作都围绕它进行。
    -   寄存器 `B` 主要配合 `MUL` 和 `DIV` 指令使用。
    -   数据指针 `DPTR` (`DPH`, `DPL`) 对于访问外部存储器 (`MOVX @DPTR`) 和程序存储器中的查找表 (`MOVC A, @A+DPTR`) 至关重要。
    -   `R0` 和 `R1` 可作为间接寻址内部RAM和外部RAM（仅低256字节，`MOVX @Ri`）的指针。
-   *堆栈管理*:
    -   在程序开始时，务必初始化堆栈指针 `SP`，通常将其指向内部RAM较高的安全区域 (例如，`MOV SP, #60H` 或更高，取决于所用RAM大小和变量区域)。
    -   `PUSH` (入栈) 和 `POP` (出栈) 指令必须成对出现且顺序相反，以保持堆栈平衡，尤其是在子程序调用和中断服务程序中。
    -   避免堆栈溢出：不要 `PUSH` 过多的数据，确保有足够的 `POP` 操作或 `SP` 调整来释放堆栈空间。
-   *标志位利用*:
    -   深刻理解各算术和逻辑指令如何影响 `PSW` 中的标志位 (`CY`, `AC`, `OV`, `P`)。
    -   熟练运用条件跳转指令 (`JC`, `JNC`, `JZ`, `JNZ`, `DJNZ`, `CJNE` 等) 来根据标志位状态实现程序分支和循环。
-   *代码优化 (简要)*:
    -   优先选用字节数少、执行周期短的指令。例如，`CLR A` (1字节, 1周期) 优于 `MOV A, #00H` (2字节, 1周期) 来清零累加器。
    -   对于短距离跳转，使用 `SJMP` (2字节, 2周期) 代替 `LJMP` (3字节, 2周期)。`AJMP` (2字节, 2周期) 适用于2KB范围内的跳转。
    -   在对时间要求严格的程序段，查阅指令手册了解各指令的准确机器周期数，进行精确延时或时序控制。
    -   巧妙利用位操作指令处理控制逻辑，MCS-51的位处理能力是一大特色。

= 实践汇编范例 (Practical Assembly Examples)

本节提供一些简单但实用的MCS-51汇编代码范例，旨在帮助理解基本的外设操作和编程技巧。

== LED 闪烁 (LED Blinking)

-   *目的 (Purpose):* 使连接到某个端口引脚（例如P1.0）的LED灯闪烁。
-   *逻辑 (Logic):* 通过不断改变P1.0引脚的电平状态（高电平 -> 低电平 -> 高电平 ...），并在每次改变状态后加入一段延时，从而实现LED的亮灭交替。
-   *代码 (Code):*
    ```asm
    ; --- LED Blinking Example ---
    ; Purpose: Blink an LED connected to P1.0
    ; Assumes: LED connected to P1.0.
    ;          If common cathode LED: P1.0 LOW = ON, P1.0 HIGH = OFF.
    ;          If common anode LED: P1.0 HIGH = ON, P1.0 LOW = OFF.
    ;          This example assumes P1.0 LOW turns the LED ON.
    ;          Crystal frequency suitable for the delay (e.g., 11.0592MHz or 12MHz).

    ORG 0000H
    LJMP MAIN_LED_BLINK

    ORG 0030H
    MAIN_LED_BLINK:
        SETB P1.0      ; Initially, turn LED OFF (P1.0 = HIGH for common cathode)
    BLINK_LOOP:
        CLR P1.0       ; Turn LED ON (P1.0 = LOW)
        LCALL DELAY    ; Call delay subroutine (LCALL for potentially larger programs)
        SETB P1.0      ; Turn LED OFF (P1.0 = HIGH)
        LCALL DELAY    ; Call delay subroutine
        SJMP BLINK_LOOP ; Repeat

    ; --- Simple Delay Subroutine ---
    ; Creates a delay. Adjust R6, R7 for different durations.
    ; For 11.0592MHz, one machine cycle is approx 1.085 µs.
    ; DJNZ takes 2 machine cycles. MOV takes 1 machine cycle.
    ; Delay approx = R6 * (1 + R7 * 2 + 1) * 1.085µs (more precise including MOVs)
    ; Rougher: R6 * R7 * 2 * MCycle_Time
    DELAY:
        MOV R6, #100   ; Outer loop count (Adjust for desired delay)
    DELAY_OUTER:
        MOV R7, #200   ; Inner loop count (Adjust for desired delay)
    DELAY_INNER:
        DJNZ R7, DELAY_INNER ; Decrement R7, jump if not zero (2 MCycles)
        DJNZ R6, DELAY_OUTER ; Decrement R6, jump if not zero (2 MCycles)
        RET                 ; (2 MCycles)

    END
    ```

== 按键读取 (Push Button Reading)

-   *目的 (Purpose):* 读取连接到P3.2引脚的按键状态，如果按键被按下，则点亮P1.1引脚的LED灯。
-   *逻辑 (Logic):* 持续检测P3.2引脚的电平。如果引脚为低电平（表示按键按下，假设使用上拉电阻，按键接地），则将P1.1置为低电平点亮LED（假设LED为共阴极接法）。如果P3.2为高电平，则将P1.1置为高电平熄灭LED。这是一个不包含软件防抖的简单示例。
-   *代码 (Code):*
    ```asm
    ; --- Push Button Reading Example ---
    ; Purpose: Read a button on P3.2, light LED on P1.1 if button pressed.
    ; Assumes: Button on P3.2, connecting P3.2 to GND when pressed.
    ;          An external pull-up resistor on P3.2 is required to ensure P3.2 is HIGH when button is not pressed.
    ;          LED on P1.1 (Common cathode: P1.1 LOW = ON, P1.1 HIGH = OFF).

    ORG 0000H
    LJMP MAIN_BUTTON_READ

    ORG 0030H
    MAIN_BUTTON_READ:
        SETB P1.1       ; Initially, turn LED OFF (P1.1 = HIGH)
        SETB P3.2       ; Configure P3.2 as input (though most 51 ports are quasi-bidirectional,
                        ; writing 1 to a pin makes it a high-impedance input)
    READ_BUTTON_LOOP:
        JB P3.2, BUTTON_NOT_PRESSED ; If P3.2 is HIGH (1), button is not pressed, jump
        ; Button is pressed (P3.2 is LOW)
        CLR P1.1                  ; Turn LED ON (P1.1 = LOW)
        SJMP READ_BUTTON_LOOP     ; Continue loop
    BUTTON_NOT_PRESSED:
        SETB P1.1                  ; Turn LED OFF (P1.1 = HIGH)
        SJMP READ_BUTTON_LOOP     ; Continue loop

    END
    ```

== 简单7段数码管驱动 (Single Digit 7-Segment Display)

-   *目的 (Purpose):* 在连接到P2口的单个7段数码管上显示一个数字（例如 '3'）。
-   *逻辑 (Logic):* 使用查表法，根据要显示的数字从预定义的表格中查找对应的7段码型，然后将该码型输出到P2口。
-   *假设 (Assumptions):*
    -   使用共阴极7段数码管。
    -   数码管的a-g段分别连接到P2.0-P2.6，小数点dp连接到P2.7（本例不使用dp）。
    -   段码对应关系：P2.0=a, P2.1=b, P2.2=c, P2.3=d, P2.4=e, P2.5=f, P2.6=g。
    -   对于共阴极数码管，对应段的引脚输出低电平 (0) 时，该段点亮。
    -   查表码型格式为 `(dp)gfedcba`，其中dp是最高位(P2.7)，a是最低位(P2.0)。码值为0表示对应段亮。
-   *代码 (Code):*
    ```asm
    ; --- Single Digit 7-Segment Display Example ---
    ; Purpose: Display a digit (0-9) on a common cathode 7-segment display.
    ; Assumes: Common cathode 7-segment display connected to P2.
    ;          P2.0=a, P2.1=b, P2.2=c, P2.3=d, P2.4=e, P2.5=f, P2.6=g. P2.7 is unused or for dp.
    ;          Lookup table provides patterns where bit=0 means segment is ON.

    ORG 0000H
    LJMP MAIN_7SEG

    ; Table of segment patterns for digits 0-9 (common cathode)
    ; Format: (dp)gfedcba. Bit=0 -> Segment ON. Here dp (P2.7) is assumed OFF (1).
    ; Example: '0' is C0H = 11000000B -> segments a,b,c,d,e,f are ON.
    ORG 0100H       ; Place table at a known address
    SEVEN_SEG_TABLE:
        DB 0C0H  ; 0: GFEDCBA = 00111111 (dp.gfedcba -> 1.1000000 -> C0H)
        DB 0F9H  ; 1: GFEDCBA = 00000110 (dp.gfedcba -> 1.1111001 -> F9H)
        DB 0A4H  ; 2: GFEDCBA = 01011011 (dp.gfedcba -> 1.0100100 -> A4H)
        DB 0B0H  ; 3: GFEDCBA = 01001111 (dp.gfedcba -> 1.0110000 -> B0H)
        DB 099H  ; 4: GFEDCBA = 01100110 (dp.gfedcba -> 1.0011001 -> 99H)
        DB 092H  ; 5: GFEDCBA = 01101101 (dp.gfedcba -> 1.0010010 -> 92H)
        DB 082H  ; 6: GFEDCBA = 01111101 (dp.gfedcba -> 1.0000010 -> 82H)
        DB 0F8H  ; 7: GFEDCBA = 00000111 (dp.gfedcba -> 1.1111000 -> F8H)
        DB 080H  ; 8: GFEDCBA = 01111111 (dp.gfedcba -> 1.0000000 -> 80H)
        DB 090H  ; 9: GFEDCBA = 01101111 (dp.gfedcba -> 1.0010000 -> 90H)

    ORG 0030H
    MAIN_7SEG:
        MOV A, #3      ; Digit to display (e.g., 3). Change this value (0-9).
        ACALL DISPLAY_ON_7SEG
        SJMP $         ; Loop indefinitely (display stays)

    DISPLAY_ON_7SEG:
        ; Input: ACC holds the digit (0-9) to be displayed.
        ; Output: P2 is set to the corresponding 7-segment pattern.
        PUSH ACC       ; Save original digit value if needed later, or if A is used by DPTR setup by caller
        MOV DPTR, #SEVEN_SEG_TABLE
        MOVC A, @A+DPTR ; Get segment pattern from table (A is offset here)
        MOV P2, A       ; Output pattern to 7-segment display connected to P2
        POP ACC        ; Restore A (if it was pushed)
        RET

    END
    ```

