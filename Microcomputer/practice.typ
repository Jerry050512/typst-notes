#import "../template/conf.typ": conf
#import "../template/components.typ": *
#import "@preview/codly:1.3.0": codly, codly-init
#import "@preview/codly-languages:0.1.8": codly-languages

#show: codly-init
#codly(languages: codly-languages)

#show: conf.with(
  title: [
    微机控制原理 习题
  ],
  authors: (
    (
      name: [Gang.],
      affiliation: [Hangzhou Dianzi University],
      email: "jerry050512@outlook.com",
    ),
  )
)

#set figure(
  numbering: none
)

#show table: it => align(center, it)

#set table(
  fill: (x, y) => if y == 0 {luma(80%)},
  align: center+horizon,
)

= 往年试卷

== 判断题

1. 8051微控制器存储结构RAM、ROM分开编址。
2. 存储器的容量与其地址线数量有关，地址线越多，容量越大。
3. 8051微控制器中工作寄存器R7的实际物理地址与PSW中的内容有关。
4. `MOV SP，#5FH`指令是将堆栈空间设置到内部RAM 60H单元开始。
5. 只有对十进制加法和减法运算，才能进行十进制调整。
6. NOP不会使微控制器产生任何操作，因此属于伪指令。
7. END表示程序指令执行到此结束。
8. 总中断允许位EA被置成“1”后，所有的中断都处于允许状态。
9. 8051微控制器中串行口的中断标志RI, TI，只能用软件进行清零。
10. 8051中的定时器/计数器，其工作方式2不存在定时误差。

*Answer Sheet*

#table(
  columns: 11, 
  [*Number*], [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], 
  [*Answer*], [T], [T], [T], [T], [F], [F], [F], [F], [T], [T]
)

1. 8051的RAM和ROM采用*分开编址*，即分别拥有独立的地址空间。ROM通常用于程序存储（程序存储器），而RAM用于数据存储（数据存储器）。
2. 存储器地址线的数量决定了可以寻址的单元数。若有 $n$ 条地址线，则最多可寻址  $2^n$ 个地址单元，地址线越多，容量越大。
3. 8051中`R0–R7`共有4组寄存器组，存储于RAM `00H–1FH`。实际使用哪组取决于`PSW`寄存器中的`RS1`和`RS0`位的值，因此R7的物理地址确实与PSW有关。
4. `MOV SP, #5FH` 将堆栈指针`SP`设置为`5FH`，那么下一次入栈操作将发生在 `60H`单元。所以可以说堆栈“从`60H`开始”。
5. 8051微控制器中，十进制调整指令`DA A`（Decimal Adjust Accumulator）通常用于BCD码（Binary-Coded Decimal）的加法运算之后，以确保结果是正确的BCD码。它不适用于减法运算。对于减法，通常采用补码运算，不需要十进制调整。
/ BCD码（Binary-Coded Decimal，二进制编码的十进制数）: 一种用4位二进制数来表示1位十进制数字（0\~9）的编码方式。具体来说，每个十进制数字用4个位的二进制数表示，范围从0000（代表0）到1001（代表9），其余6种4位组合（1010到1111）不属于有效编码。
6. `NOP` 是“无操作”指令，*占用一个机器周期执行*，但它是真正的机器指令，在代码中会被编译；伪指令如END不会生成机器代码。
7. *`END` 是伪指令*，用于告诉汇编器源程序到此结束，而不是控制程序运行结束。程序运行结束依赖指令如`SJMP $`或调用`RET`返回等。
8. 设置 `EA=1` 是总中断使能条件，但每个中断源还需其*对应的中断允许位*（如`EX0`、`ET0`等）也被置1才真正允许。因此 `EA=1` 不等于“所有中断都使能”。
9. 串行口的接收中断标志位`RI`（Receive Interrupt）和发送中断标志位`TI`（Transmit Interrupt）在硬件检测到接收完成或发送完成后会自动置1，以产生中断请求。然而，它们不会被硬件自动清零。在中断服务程序中，必须通过软件（例如`CLR RI`和`CLR TI`指令）手动将它们清零，否则将导致重复中断。
10. 8051定时器的工作方式2（8位自动重装载模式）虽然在*理论上可以实现精确的周期定时*，但仍然存在定时误差。这种误差主要来源于以下几个方面：
  - 指令周期误差： 定时器计数是基于机器周期的，而指令的执行需要不同的机器周期数。中断服务程序和主程序的指令执行会占用CPU时间，导致计时不连续。
  - 中断响应时间： 当定时器溢出请求中断时，CPU需要一定的时间来响应中断、保存现场、跳转到中断服务程序。这段时间也是一种误差。
  - 晶振误差： 无论什么工作方式，定时器的精度都依赖于外部晶振的精度。晶振本身可能存在频率偏差。 因此，工作方式2只是相对其他方式而言更方便实现固定周期定时，但并非完全没有误差。

== 选择题

1. 若FEH是有符号数，其代表的数值是#underline("       ")。\  
  A. -1 \
  B. -2 \
  C. -254 \
  D. -127 
2. 在8051MCU中，反映程序运行状态或反映运算结果特征的特殊功能寄存器是#underline("       ")。\ 
  A. `PCB` \
  B. `PSW` \
  C. `A` \
  D. `SP` 
3. 已知`A`的值为`98H`，将其与`0FAH`相加，标志位`Cy`，`AC`，`OV`，`P`的值分别是#underline("       ")。 \
  A. 0,0,0,1 \
  B. 1,0,1,0 \
  C. 1,1,1,1 \
  D. 1,1,0,1 
4. 指令系统中的寻址方式就是#underline("       ")的方式。 \
  A.查找指令操作码 \
  B.查找指令 \
  C.查找指令操作数 \
  D.查找指令操作数与操作码
5. 执行`PUSH A`指令，8051微控制器完成的操作是#underline("       ")。\ 
  A. `(SP)+1→(SP), (A)→((SP))` \
  B. `(A)→((SP)), (SP)-1→(SP)` \
  C. `(SP)-1→(SP), (A)→(SP))` \
  D. `(A)→((SP), (SP)+1→(SP)` 
6. 下列指令中，没有用到8051微控制器堆栈区的是#underline("       ")。 \ 
  A. `LCALL` \
  B. `ADD` \
  C. `PUSH` \
  D. `RET` 
7. 已知`(A)=0DBH`，`(R4)=73H`，`(C)=1`，执行指令`SUBB A, R4`后的结果是#underline("       ")。 \ 
  A. `(A)=73H` \
  B. `(A)=ODBH` \
  C. `(A)=67H` \
  D. 以上都不对 
8. 处于同一级别的5个中断源同时请求中断时，CPU响应中断的次序为#underline("       ")。  \
  A. 串行口、T1、INT1、T0、INT0 \
  B. INT0、T0、INT1、T1、串行口 \ 
  C. 串行口、INT1、T1、INT0、T0 \
  D. T0、INT0、T1、INT1、串行口 
9. 进行BCD码加法运算时，对加法结果进行十进制调整的指令是#underline("       ")。  \
  A. `ADD` \
  B. `ADDC` \
  C. `DA A` \
  D. 由实际程序确定 
10. 8051 MCU的中断源和中断标志位的个数分别为#underline("       ")。 \ 
  A. 5、5 \
  B. 5、6 \
  C. 6、6 \
  D. 6、5 
11. 微控制器响应中断时，保护现场的工作#underline("       ")。 \
  A. 由CPU自动完成 \
  B. 在中断响应时完成 \
  C. 由中断服务程序完成 \
  D. 在主程序中完成 
12. 当8051微控制器响应外部中断0后，`PC`的值是#underline("       ")。 \
  A. `0000H` \
  B. `0003H` \
  C. `000BH` \
  D. `0013H` 
13. 启动定时器1工作的指令是使 `TCON`的#underline("       ")。 \
  A. TF1位置1 \
  B. TR1位置1 \
  C. TR1位置0 \
  D. TR0位置0 
14. 当`T0`工作在定时工作方式1时，其最长定时时间为#underline("       ")。（晶振频率12MHz） \
  A. 65536μs \
  B. 4096μs \
  C. 16384μs \
  D. 8192μs 
15. 假设晶振频率为12MHz，要实现50ms的定时，定时器0的工作方式为1，则初值为 #underline("       ")。 \
  A. `TH0=0CH, TL0=78H` \
  B. `TH0=0ECH, TL0=78H` \
  C. `TH0=3CH, TL0=B0H` \
  D. `TH0=B0H, TL0=3CH` 
16. 8051 微控制器中，定时器/计数器的位数是#underline("       ")。 \
  A. 8位 \
  B. 16位 \
  C. 13位 \
  D. 由工作方式决定的 
17. 异步串行通信中，收发双方必须保持#underline("       ")。 \
  A. 收发时钟相同 \
  B. 系统晶振相同 \
  C. 数据帧格式和波特率相同 \
  D. 以上都正确 
18. 设某12位D/A转换满量程输出电压为5V，此转换器的电压分辨率为#underline("       ")mV。 \
  A. 1.22 \
  B. 2.44 \
  C. 4.88 \
  D. 19.6 
19. 对于数据采集系统，应根据被测量信号的频率，选择ADC的#underline("       ")。 \
  A. 分辨率 \
  B. 转换精度 \
  C. 转换时间 \
  D. 线性度 
20. 利用8051微控制器的UART扩展I/O接口时，应选择工作于#underline("       ")。 \
  A. 并行通信方式 \
  B. 10位异步通信方式 \
  C. 11位异步通信方式 \
  D. 同步移位寄存器输入/输出方式 

*Answer Sheet*

#table(
  columns: 11, 
  [*Number*], [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], 
  [*Answer*], [B], [B], [D], [C], [A], [B], [C], [B], [C], [B], 
  [*Number*], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], 
  [*Answer*], [C], [B], [B], [A], [C], [D], [C], [A], [C], [D], 
)

1. 在计算机中，有符号数通常使用补码表示。
首先，将十六进制数 FEH 转换为二进制：`1111 1110B`。
由于最高位是1，表示这是一个负数。
求其补码的真值：
- 减1：`1111 1110B` - 1 = `1111 1101B`
- 按位取反（求反码）：`0000 0010B`
- 将反码转换为十进制： $2^1 = 2$
所以，`FEH`代表的数值是 $-2$。

2. 
- `PSW` (Program Status Word) 寄存器包含了反映CPU当前工作状态的各种标志位，如进位标志`CY`、辅助进位标志`AC`、溢出标志`OV`、奇偶校验标志`P`以及寄存器组选择位`RS0`和`RS1`。它直接反映了运算结果的特征和程序运行状态。
- `A`是累加器，用于数据运算。
- `SP`是堆栈指针。
- `PCB`不是8051中的标准特殊功能寄存器名称。

3. `A = 98H = 1001 1000B`, `0FAH = 1111 1010B`, 执行加法：
```
  1001 1000   (98H)
+ 1111 1010   (FAH)
-----------
1 1001 0010   (192H)
```
- CY (Carry Flag, D7进位): D7位向外有进位，所以 CY = 1。
- AC (Auxiliary Carry Flag, D3进位): D3位进位，所以 AC = 1。
- OV (Overflow Flag, 溢出): 如果两个正数相加结果为负数，或者两个负数相加结果为正数，则 OV = 1。此处没有溢出. 
- P (奇偶标志): 保证有偶数个1, 此处有3个1, 故P = 1. 

4. / 寻址方式: 指CPU在执行指令时，*寻找操作数所在的地址*的方式。指令的操作码指示了操作的类型，而操作数则是进行操作的数据。寻址方式决定了如何根据指令中的地址信息来获取操作数。

5. 8051的堆栈是向上增长的，即堆栈指针`SP`在数据入栈前先自增，然后将数据存入`SP`指向的新地址。
  - `(SP)+1→(SP)`：堆栈指针先自增1。
  - `(A)→((SP))`：将累加器A中的内容压入到SP指向的（新）地址。

6. 
  - `LCALL` (Long Call)：*调用子程序*指令，会将返回地址*压入堆栈*。
  - `ADD` (Add): 加法指令，*只涉及寄存器和/或存储器之间*的数据操作，不使用堆栈。
  - `PUSH`: 压栈指令，明确地将数据*压入堆栈*。
  - `RET` (Return): 从子程序返回指令，会从堆栈中*弹出返回地址*。

7. `SUBB A, R4`指令的含义是 `A = A - R4 - C`。\
  `(A) = 0DBH` \
  `(R4) = 73H` \
  `(C) = 1` \
  - 计算：`0DBH - 73H - 1`
  - 转换为十进制：`219 - 115 - 1 = 103`
  - 将103转换为十六进制：`103 / 16 = 6` 余 `7`。所以 `103D = 67H`。
  因此，`(A)`的值将是 `67H`。

8. 8051微控制器在中断优先级相同时，会按照固定的查询顺序（内部优先级）来响应中断。这个固定顺序是从高到低依次为：
  `INT0` (外部中断0), 
  `T0` (定时器0), 
  `INT1` (外部中断1), 
  `T1` (定时器1), 
  串行口 (Serial Port)

9. `DA A` (Decimal Adjust Accumulator) 是十进制调整指令，专门用于在执行BCD码加法（无论是ADD还是ADDC）后，将累加器A中的结果调整为正确的BCD码形式。

10. 8051微控制器有5个中断源：
  - 外部中断0 (`INT0`)
  - 定时器/计数器0 (`T0`)
  - 外部中断1 (`INT1`)
  - 定时器/计数器1 (`T1`)
  - 串行口 (`TI` 或 `RI`，被视为一个中断源)
  而对应的中断标志位有6个：
  - `IE0` (外部中断0标志)
  - `TF0` (定时器0溢出标志)
  - `IE1` (外部中断1标志)
  - `TF1` (定时器1溢出标志)
  - `RI` (串行口接收中断标志)
  - `TI` (串行口发送中断标志)
  虽然串行口被视为一个中断源，但它有`RI`和`TI`两个独立的中断标志位。

11. 8051微控制器在响应中断时，CPU自动完成的操作仅仅是将当前的程序计数器 `PC` 的值（即返回地址）压入堆栈，并将 `PC` 设置为中断向量地址。保护现场，即保存其他可能被中断服务程序修改的寄存器（如`A`、`B`、`PSW`、`R0-R7`等）的内容，是由中断服务程序（`ISR`）的编写者通过指令（如`PUSH`指令）来完成的。这是为了确保中断服务程序执行完毕后，主程序能够恢复到中断前的正确状态。

12. 8051微控制器有固定的中断向量地址。当CPU响应外部中断0（`INT0`）后，程序计数器`PC`会自动加载外部中断0的中断向量地址，即`0003H`。
  - `0000H`是复位向量地址。
  - `000BH`是定时器0中断向量地址。
  - `0013H`是外部中断1中断向量地址。

13. `TCON`（Timer Control Register）是定时器/计数器的控制寄存器。其中的 `TR0` 和 `TR1` 位是定时器/计数器的启动/停止控制位。
  - `TR1`（Timer 1 Run Control Bit）：当 TR1 置1时，定时器1开始计数；当 TR1 置0时，定时器1停止计数。
  - `TF1` 是定时器1的溢出标志位，由硬件置1，表示溢出。

14. 
  - 机器周期： 8051在12MHz晶振下，一个机器周期是 
  $ T_m = 12 / (12"MHz") = 1"μs" $
  - 工作方式1： 定时器/计数器0工作在方式1时是16位定时器。这意味着它可以从`0000H`计数到`FFFFH`。
  - 最大计数次数： 
  $ 2^16 = 65536 次 $
  - 最长定时时间： 
  $ "最大计数次数" times "每个机器周期的时间" = 65536 times 1"μs" = 65536"μs" $

15. 
  - 机器周期： 12MHz晶振下，一个机器周期是 1μs。
  - 定时时间转换成机器周期数： 50ms=50000μs。
  - 计数初值计算： 对于16位定时器（方式1），计数器从初值开始递增到`FFFFH`才溢出。
  - 设需要的计数次数为N，则 
  $ N = "定时时间" / "机器周期" = (50 times 10^3"μs") / (1"μs") = 50000 $
  $ "初值" = 65536 - N = 65536 - 50000 = 15536 "(十进制)"$
  - 将初值转换为十六进制：
    - 15536÷256=60 余 176
    - 60D = 3CH
    - 176D = B0H
  所以，初值 `TH0 = 3CH`，`TL0 = B0H`。

16. 8051微控制器内部的定时器/计数器（T0和T1）本质上都是16位的计数器。它们可以被编程为不同的工作方式：
  - 方式0：13位定时器
  - 方式1：16位定时器
  - 方式2：8位自动重装载定时器
  - 方式3：T0分为两个8位定时器，T1停止计数 虽然它们可以在不同的工作方式下表现出8位或13位的功能，但其核心计数寄存器 (`THx` 和 `TLx`) 组合起来始终是16位。

17. 在异步串行通信中：
- 数据帧格式（起始位、数据位、校验位、停止位）必须一致，以便正确地解析数据。
- 波特率（每秒传输的位数）必须相同，这样收发双方才能以相同的速率采样数据，避免误码。
- 收发时钟不一定相同，因为是异步通信，各自有自己的时钟，通过数据同步。
- 系统晶振不一定相同，只要波特率能通过分频或其他方式调整到一致即可。

18. / 分辨率: D/A转换器的分辨率是指它能分辨出的最小输出电压变化量，通常是满量程输出电压除以 $2^N - 1$ 或 $2^N$ （取决于是否包含零）。对于N位D/A转换器，分辨率是 $V_"FS" / (2^N - 1)$ 或 $V_"FS" / 2^N$。在多数计算中，为了简化，通常用 $V_"FS" / 2^N$。
  - 满量程输出电压 $V_"FS"$=5V=5000mV。
  - 位数 N=12。
  - $2^12 = 4096$。
  - 分辨率 = 5000mV/4096≈1.2207mV。

19. 
  - 转换时间：ADC将模拟信号转换为数字信号所需的时间。根据奈奎斯特采样定理，采样频率至少是被测信号最高频率的两倍。因此，ADC的转换时间（或者说采样速率）必须足够快，才能跟上信号频率的变化，避免信号失真。
  - 分辨率：决定了数字输出的精细程度，与信号的幅值范围和测量精度要求有关。
  - 转换精度：衡量转换结果的准确性。
  - 线性度：反映ADC输入/输出关系的线性程度。 
  虽然分辨率、精度和线性度也很重要，但转换时间是直接决定ADC是否能有效采集特定频率信号的关键参数。

20. 8051的UART（通用异步收发器，即串行口）除了用于串行通信外，还可以配置在工作方式0。
  - 工作方式0是同步移位寄存器输入/输出方式。在这种模式下，串行口被用作一个同步移位寄存器，可以方便地进行8位数据的串行输入或输出，常用于扩展并行I/O口（例如驱动LED、读取按键等），因为它提供了同步时钟输出。
  - 10位/11位异步通信方式是用于标准的串行通信。

== 填空题

1. 按使用功能，通常将内部RAM区划分为  #underline("       ")、#underline("       ") 和 #underline("       ") 三个区域。 
2. 微机中的存储器通常采用 #underline("       ") 和普林斯顿两种基本结构形式，采用的两种指令集体系是 #underline("       ") 和精简指令集计算机(RISC)。 
3. 在中断程序中，保护工作寄存器的方法有 #underline("       ") 、 #underline("       ") 和存储器保护。 
4. 设`(A) = 56H`，`(B) = 81H`，请写出执行下述指令后的结果
  ```asm
  ADD  A，B 
  DA   A 
  ```
  (A) = #underline("       ") ；(C) = #underline("       ") ；(P)= #underline("       ") 。 
5. 按照数据传输方向，串口通信可分 #underline("       ") 、 #underline("       ") 和 #underline("       ") 三种基本传送方式。 
6. CPU和外设进行数据交换时，常用的两种方式为 #underline("       ") 、 #underline("       ") 。 

*Answer Sheet*

#table(
  columns: (auto, 1fr), 
  [*Number*], [*Answer*], 
  [1], [工作寄存器区、位寻址区和用户RAM区], 
  [2], [哈佛, 复杂指令集计算机（CISC）],
  [3], [堆栈保护, 切换工作寄存器组保护], 
  [4], [`37H`, `1`, `1`], 
  [5], [单工、半双工和全双工], 
  [6], [查询, 中断]
)

1. 8051微控制器的内部RAM（128字节）根据其功能和寻址方式被划分为三个主要区域：
  - 工作寄存器区 (`00H-1FH`)： 包含`R0-R7`共四组，用于快速数据操作，由`PSW`寄存器选择当前使用的寄存器组。
  - 位/字节寻址区 (`20H-2FH`)： 这16个字节既可以进行字节寻址，也可以进行位寻址，非常适合对单个标志位进行操作。
  - 用户RAM区 (`30H-7FH`)： 作为通用数据存储区，通常用作堆栈区和用户程序的数据存储。

2. 
  - 微机中的存储器结构主要有两种：哈佛结构（程序存储器和数据存储器分开，有独立的地址总线和数据总线）和普林斯顿结构（又称冯·诺依曼结构，程序存储器和数据存储器共用地址总线和数据总线）。8051微控制器内部采用的是哈佛结构。
  - 指令集体系结构主要有两类：复杂指令集计算机(CISC)，其指令集庞大且功能复杂，一条指令可以完成多种操作；以及精简指令集计算机(RISC)，其指令集较小，每条指令功能单一，但执行速度快。8051属于CISC架构。

3. 在中断服务程序中，为了不影响主程序的正常运行，需要保存那些可能被中断程序修改的寄存器内容，这通常称为“保护现场”。主要有两种方法：
  - 堆栈保护： 最常用的方法，通过`PUSH`指令将工作寄存器（`A`, `B`, `PSW`, `R0-R7`等）压入堆栈，在中断服务程序结束前用`POP`指令恢复。
  - 切换寄存器组： 8051有四组`R0-R7`工作寄存器。在中断服务程序的开头，可以通过修改`PSW`寄存器的`RS0`和`RS1`位，切换到另一组未被主程序使用的寄存器组，从而避免覆盖主程序的工作寄存器内容。中断返回前再切换回原来的寄存器组。
  - 存储器保护： 这是指将寄存器内容保存到内部或外部RAM的特定地址。

4. 
- ADD A, B：
  - 56H + 81H = D7H（无符号数：86 + 129 = 215）。
  - 标志位：
    - CY = 0（无进位，215 < 256）。
    - AC = 1（低4位：6H + 1H = 7H，无半进位？实际计算：0110+0001=0111，无进位，AC=0。但调整规则基于AC和CY）。
    注：DA A调整规则依赖AC和CY，但实际计算时需按BCD码逻辑。
- DA A（十进制调整）：
  - 调整规则（针对BCD码加法）：
    - 若低4位 > 9 或 AC = 1，则加06H。
    - 若高4位 > 9 或 CY = 1，则加60H。
  - 此处A = D7H（非BCD码），但按规则：
    - 低4位（7）< 10，但高4位（13）> 9 → 需加60H。
    - 调整后：D7H + 60H = 137H → A = 37H，CY = 1（进位）。
  - 奇偶标志P：37H = 0011 0111（二进制），含5个1（奇数），故P = 1。

5. 串口通信根据数据传输的方向性，可以分为：
  - 单工(Simplex)： 数据只能在一个方向上传输，不能反向。例如，广播。
  - 半双工(Half-duplex)： 数据可以在两个方向上传输，但在同一时间只能在一个方向上传输。例如，对讲机。
  - 全双工(Full-duplex)： 数据可以在两个方向上同时传输。例如，电话。

6. CPU与外设进行数据交换或控制时，主要有以下几种方式：
  - 程序查询方式： CPU不断地查询外设的状态标志，判断外设是否准备好进行数据交换。这种方式简单，但效率低，CPU占用率高。
  - 中断方式： 外设在需要CPU服务时（如数据准备好、操作完成等），向CPU发送中断请求信号，CPU响应中断后暂停当前任务，转去执行中断服务程序。这种方式效率较高，提高了CPU的利用率。
  - DMA方式 (直接存储器存取)： 适用于大量数据的传输。DMA控制器直接在外设和存储器之间传输数据，无需CPU干预，进一步提高了传输效率和CPU利用率。问题中只要求两种常用方式，通常指前两种。

== 简答题

1. 简述CPU的主要组成部分以及各部分的功能。 

#block(height: 10%)

2. 8051单片机中MOV、MOVC、MOVX指令有什区别？分别用在哪些场合?为什么? 

#block(height: 10%)

3. 简述中断的概念。 

#block(height: 10%)

4. 串行异步通信有哪些特点?其数据帧由哪几部分组成? 

#block(height: 10%)

*Answer Sheet*

1. 简述CPU的主要组成部分以及各部分的功能。

CPU（Central Processing Unit），即中央处理器，是计算机系统的核心部件，负责解释计算机指令以及处理计算机软件中的数据。它主要由以下三个部分组成：

- *运算器 (ALU - Arithmetic Logic Unit)：*运算器是CPU的执行单元，负责执行所有的算术运算（如加、减、乘、除）和逻辑运算（如与、或、非、异或、比较）。它是CPU进行数据加工和处理的核心部件。
- *控制器 (Control Unit)：*控制器是CPU的指挥中心，负责协调和控制计算机系统各部件的工作。它根据指令的要求，从存储器中取出指令，并对指令进行译码，然后发出控制信号，指挥运算器、存储器以及输入/输出设备协同工作，完成指令执行的整个过程。
- *寄存器组 (Registers)：*寄存器是CPU内部用于临时存储数据、地址和控制信息的存储单元。它们是CPU处理数据时速度最快的存储区域。常见的寄存器包括累加器（A）、数据指针（DPTR）、程序计数器（PC）、堆栈指针（SP）以及通用工作寄存器（R0-R7）等，它们为CPU提供快速的数据存取能力，极大地提高CPU的运行效率。

2. 8051单片机中MOV、MOVC、MOVX指令有什么区别？分别用在哪些场合？为什么？

在8051单片机中，`MOV`、`MOVC` 和 `MOVX` 是三条功能相似但操作对象和寻址空间截然不同的数据传送指令。

- *MOV (Move Data)：*
    - *功能：*这是一条最常用的数据传送指令，用于在*内部RAM、特殊功能寄存器（SFR）*以及*工作寄存器*之间进行字节数据传送。
    - *寻址空间：*内部数据存储器和特殊功能寄存器。
    - *场合：*
        - 在内部RAM单元之间传递数据。
        - 将常数（立即数）装入寄存器或内部RAM。
        - 读写特殊功能寄存器，如设置定时器初值、配置串行口模式等。
    - *为什么：*`MOV`指令速度快，可以直接访问片内所有的数据存储器和SFR，是8051进行内部数据操作的首选指令。

- *MOVC (Move Code)：*
    - *功能：*这是一条*程序存储器读指令*，用于从*程序存储器（ROM）*中读取数据到累加器A。指令中的`C`表示"Code"（代码），强调其数据源是程序存储器。
    - *寻址空间：*程序存储器。它使用累加器A和数据指针DPTR（或程序计数器PC）共同构成16位地址。
    - *场合：*
        - 读取查表数据：程序中存储的表格、字符常数、汉字字模等。
        - 作为常数表使用：例如，存储LED显示码表、中断向量表等。
    - *为什么：*8051的程序存储器和数据存储器是分开编址的（哈佛结构）。`MOVC`是唯一能够访问程序存储器中数据的指令，通过DPTR或PC作为基地址，A作为偏移量，可以实现对程序存储器内容的灵活读取。

- *MOVX (Move External Data)：*
    - *功能：*这是一条*外部数据存储器读写指令*，用于在*累加器A*和*外部RAM*之间进行字节数据传送。指令中的`X`表示"External"（外部）。
    - *寻址空间：*外部数据存储器。它可以进行8位（P0口作为地址/数据复用）或16位（P0口作数据，P2口作高8位地址）寻址。
    - *场合：*
        - 扩展外部RAM：当片内RAM不够用时，用于读写外部扩展的RAM芯片。
        - 访问具有RAM接口的外设：如外部ADC/DAC芯片等。
    - *为什么：*8051的外部RAM和内部RAM是分开的，需要专门的控制信号（如`/WR`、`/RD`、`/PSEN`）和总线操作来访问。`MOVX`指令提供了这些必要的控制时序，使其能够与外部存储器进行数据交换。

3. 简述中断的概念。

*中断*是指CPU在执行程序的过程中，遇到外部（如键盘输入、定时器溢出、串口接收等）或内部（如除数为零、非法指令等）的紧急事件或请求时，暂停当前正在执行的程序，转去处理该紧急事件或请求，待处理完毕后再返回到原程序被中断的地方继续执行的一种机制。

*主要特点：*

- *非同步性：*中断的发生是随机的，不与CPU正在执行的程序同步。
- *异步处理：*中断允许CPU在不影响主程序连续性的前提下，及时响应并处理突发事件。
- *提高效率：*通过中断，CPU无需持续查询外设状态，可以做更多有效的工作，当外设需要服务时再响应，大大提高了CPU的利用率和系统的实时响应能力。
- *保护现场与恢复现场：*为了在中断处理完毕后能正确返回主程序，CPU在响应中断时会自动保存程序计数器（PC），而中断服务程序则需要程序员编写代码来保存其他关键寄存器的内容（保护现场），并在返回前恢复（恢复现场）。

4. 串行异步通信有哪些特点？其数据帧由哪几部分组成？

串行异步通信是一种数据传输方式，其特点是不需要收发双方提供同步时钟信号，而是通过约定好的数据帧格式和波特率来实现数据的可靠传输。

*主要特点：*

1.  *无同步时钟线：*收发双方各自使用独立的内部时钟，通过数据帧中的起始位实现同步。
2.  *传输效率相对较低：*因为每一帧数据都需要额外的起始位和停止位来标记开始和结束，增加了传输的开销。
3.  *实时性要求不高：*适用于对实时性要求不严格、传输距离相对较远的应用场景。
4.  *成本低廉：*只需要两根或三根线（数据发送、数据接收和地线）即可实现通信。
5.  *灵活性高：*允许两端设备使用不同的晶振频率，只要能通过分频等方式得到相同的波特率即可。

*数据帧的组成部分：*

一个典型的串行异步通信数据帧通常由以下几部分组成：

1.  *空闲位：*在没有数据传输时，数据线通常保持在高电平状态，这被称为空闲位。
2.  *起始位 (Start Bit)：*始终是一个低电平位。它标志着一帧数据传输的开始，并用于接收端与发送端时钟的同步。
3.  *数据位 (Data Bits)：*实际要传输的数据，通常为5位、6位、7位或8位。最不常用的组合是9位数据位（常见于8051的串行通信方式2和3）。数据位通常是低位在前，高位在后（LSB-first）。
4.  *奇偶校验位 (Parity Bit，可选)：*用于数据传输的错误检测。可以是奇校验（使1的个数为奇数）或偶校验（使1的个数为偶数）。如果不使用校验，则没有此位。
5.  *停止位 (Stop Bit)：*始终是一个高电平位。它标志着一帧数据的结束，并为下一帧数据的起始位做好准备。可以是1位、1.5位或2位停止位，最常用的是1位停止位。

数据帧的典型顺序是：`空闲位 -> 起始位 -> 数据位 -> [校验位] -> 停止位 -> 空闲位`。

== 程序阅读题

1. 阅读下面的子程序段
  ```asm
  SUB1: ADD A, #99H 
        DA  A 
        RET
  ```
  i. 该子程序的主要功能：#underline("       ")。 \
  ii. 如果A=56H，该子程序调用结束后，A=#underline("       ")H； \
    如果A=23H，该子程序调用结束后，A=#underline("       ")H。

2. 阅读下面的子程序段
  ```asm
  SUB1: MOV  R0,  #30H 
        MOV  R1,  #50H 
        MOV  R3,  #08H 

  LOOP: MOV  A,   @R0 
        MOV  @R1, A 
        INC  R0 
        INC  R1 
        DJNZ R3,  LOOP 
        RET 
  ```
  i. 该子程序段的主要功能：#underline("       ")。 \
  ii. 该子程序运行结束后，(R0)= #underline("       ") H,  ( R1)= #underline("       ") H,  (R3)= #underline("       ") H。

3. 阅读程序并填空，代码功能为找到DPTR所指向外部RAM数组中最大的值，数组长度
记录在R1中。
  ```asm
  SUB3:  MOV  00H,  #00H 
  LOOP:  ____ A,    @DPTR 
        ____ DPTR 
        CLR  ____  
        CJNE A,    00H,  testC 
  testC: ____ NEXT 
        MOV  00H,  A 
  NEXT:  DJNZ ____, LOOP 
        RET
  ```

*Answer Sheet*

1. 
  i. 按照压缩的BCD码表示的十进制数对累加器A的值加99 \
  ii. 55; 22;

i. 该子程序的主要功能： 实现累加器A与99H的BCD码加法运算。

解析：

- `ADD A, #99H`：这是一条二进制加法指令，将立即数99H（十六进制）与累加器A中的内容进行二进制相加，结果存回A。
- `DA A`：这是一条十进制调整指令。它通常在执行完BCD码加法（ADD或ADDC）后使用，用于将累加器A中的二进制结果调整为正确的BCD（Binary-Coded Decimal）码格式。
- `RET`：子程序返回指令。
综合来看，这个子程序的核心目的是对A中的一个BCD码数和99H这个BCD码数进行十进制加法运算。

ii. 如果A=56H，该子程序调用结束后，A= 55H；
如果A=23H，该子程序调用结束后，A= 22H。

解析：

- 情况一：A = 56H
  - `ADD A, #99H`：
    - A = 56H (二进制 0101 0110B)
    - 99H (二进制 1001 1001B)
    - 二进制相加：
    ```
      0101 0110 (56H)
    + 1001 1001 (99H)
    ------------
      1110 1111 (EFH)
    ```
    此时 A = EFH。
  - `DA A`：对 EFH 进行BCD调整。
    - EFH 的低四位是 FH (即 1111B)，大于9。根据DA A规则，A的低四位若大于9或AC=1，则A的低四位加06H。
      - EFH + 06H = F5H (二进制 1111 0101B)
    - F5H 的高四位是 FH (即 1111B)，大于9。根据DA A规则，A的高四位若大于9或CY=1，则A的高四位加60H。
      - F5H + 60H = 155H。结果的低8位为 55H。
      - 由于最高位有进位，CY标志位会置1。
    - 所以，最终 A = 55H。

  从十进制角度看：56 (BCD) + 99 (BCD) = 155 (BCD)。由于8051的累加器是8位的，只能保存155的低两位，即55，而高位1则反映在CY标志位上。

- 情况二：A = 23H
  - `ADD A, #99H`：
    - A = 23H (二进制 0010 0011B)
    - 99H (二进制 1001 1001B)
    - 二进制相加：
    ```asm
      0010 0011 (23H)
    + 1001 1001 (99H)
    ------------
      1011 1100 (BCH)
    ```
    此时 A = BCH。
  - `DA A`：对 BCH 进行BCD调整。
    - BCH 的低四位是 CH (即 1100B)，大于9。根据DA A规则，A的低四位若大于9或AC=1，则A的低四位加06H。
      - BCH + 06H = C2H (二进制 1100 0010B)
    - C2H 的高四位是 CH (即 1100B)，大于9。根据DA A规则，A的高四位若大于9或CY=1，则A的高四位加60H。
      - C2H + 60H = 122H。结果的低8位为 22H。
      - 由于最高位有进位，CY标志位会置1。
  - 所以，最终 A = 22H。
  从十进制角度看：23 (BCD) + 99 (BCD) = 122 (BCD)。同样，累加器只能保存低两位22，高位1反映在CY标志位上。

2. 
  i. 将内部RAM 30H开始的8个操作数移动到内部RAM 50H开始的存储器空间 \
  ii. 38,  58, 00

i. 该子程序段的主要功能：*将内部RAM从30H开始的8个字节数据块复制到从50H开始的内存区域。*

*解析：*

  - `MOV R0, #30H`：初始化寄存器 `R0` 为源地址指针，指向内部RAM的 `30H` 单元。

  - `MOV R1, #50H`：初始化寄存器 `R1` 为目的地址指针，指向内部RAM的 `50H` 单元。

  - `MOV R3, #08H`：初始化寄存器 `R3` 为循环计数器，设定为 `8`，表示将复制8个字节的数据。

  - *`LOOP:`*(循环开始标记)

      - `MOV A, @R0`：将 `R0` 指向的内存单元（源地址）中的数据传送到累加器 `A`。
      - `MOV @R1, A`：将累加器 `A` 中的数据传送到 `R1` 指向的内存单元（目的地址）。
      - `INC R0`： `R0` 自增1，使其指向下一个源地址。
      - `INC R1`： `R1` 自增1，使其指向下一个目的地址。
      - `DJNZ R3, LOOP`： `R3` 减1，如果 `R3` 不为零，则跳转到 `LOOP` 标签处继续执行；如果 `R3` 为零，则跳出循环。

  - `RET`：子程序返回。

结合所有指令，该子程序的功能是从内部RAM的 `30H` 地址开始，将8个字节的数据块复制到内部RAM的 `50H` 地址开始的区域。这是一个典型的内存块复制操作。

ii. *该子程序运行结束后，(R0)=38H, (R1)=58H, (R3)=00H*。

*解析：*

  - *R0：*初始值为 `30H`。在循环中，每次复制一个字节后 `R0` 都会 `INC`（自增）一次。循环执行了8次（由 `R3` 控制）。
      - 最终 `R0` 的值为 `30H + 8 = 38H`。
  - *R1：*初始值为 `50H`。与 `R0` 类似，每次复制后 `R1` 也会 `INC`（自增）一次。循环执行了8次。
      - 最终 `R1` 的值为 `50H + 8 = 58H`。
  - *R3：*初始值为 `08H`。`DJNZ` 指令每次循环都会使 `R3` 减1。当 `R3` 减到 `00H` 时，循环结束。
      - 最终 `R3` 的值为 `00H`。

3. `MOVX`, `INC`, `C`, `JC`, `R1`

```asm
SUB3:   MOV  00H,  #00H
LOOP:   MOVX A,    @DPTR  ; 从DPTR指向的外部RAM读取数据到A
        INC  DPTR        ; DPTR自增，指向下一个外部RAM单元
        CLR  C           ; 清除进位标志C，为CJNE指令的比较做准备
        CJNE A,    00H,  testC ; 比较A和00H单元的内容，如果A > 00H，则C=0。如果 A < 00H，则C=1。
testC:  JC  NEXT         ; 如果 C=1 (即 A < (00H))，则跳转到NEXT（不更新）
                          ; 如果 C=0 (即 A >= (00H))，则不跳转，执行MOV 00H, A
        MOV  00H,  A     ; 将A的值（当前最大值）保存到00H单元
NEXT:   DJNZ R1,   LOOP  ; R1减1，如果R1不为零，则跳转到LOOP继续循环
        RET
```

*解析：*

这个子程序的目标是从DPTR指向的外部RAM数组中找到最大的值，并将这个最大值存储在内部RAM的 `00H` 单元中。`R1` 寄存器存储了数组的长度，即需要比较的元素个数。

  - *`MOV 00H, #00H`*: 初始化 `00H` 单元为 `00H`。这个单元将用来存放当前找到的最大值。假设数组中的值都是非负数，初始为0是一个合理的起点。
  - *`LOOP: MOVX A, @DPTR`*: 这是从*外部RAM*读取数据的指令。因为数组在外部RAM中，所以使用 `MOVX`。它将 `DPTR` 指向的外部RAM中的数据读到累加器 `A`。
  - *`INC DPTR`*: 读取一个数据后，`DPTR` 需要自增1，指向数组中的下一个元素，以便下次循环读取。
  - *`CLR C`*: 在使用 `CJNE` 指令比较时，`CJNE` 指令会影响 `C` 标志位。通常 `CJNE A, #data, rel` 如果 `A < #data`，则 `C=1`；如果 `A > #data`，则 `C=0`。如果 `A = #data`，则 `C` 不变。为了正确判断 `A` 是否大于 `00H` 中的当前最大值，需要先清除 `C` 标志位。
  - *`CJNE A, 00H, testC`*: 这条指令比较累加器 `A` 的内容和内部RAM单元 `00H` 的内容。
      - 如果 `A` *不等于*`00H`，则跳转到 `testC`。
      - 如果 `A` *等于*`00H`，则不跳转，直接执行下一条指令（即 `JNC NEXT`）。
  - *`testC: JNC NEXT`*: 这条指令利用了 `CJNE` 指令对 `C` 标志位的影响来判断大小。
      - `JC NEXT` (Jump if No Carry)：如果 `C = 1`，则跳转到 `NEXT`。
      - 结合 `CJNE A, 00H, testC`：
          - 如果 `A > 00H`，则 `CJNE` 会使 `C = 0`。此时 `JC NEXT` *不跳转*，执行 `MOV 00H, A`，更新最大值。
          - 如果 `A < 00H`，则 `CJNE` 会使 `C = 1`。此时 `JC NEXT` *跳转*，执行 `MOV 00H, A`，不更新最大值。 
  - *`MOV 00H, A`*: 如果当前读取的 `A` 的值大于 `00H` 中存放的当前最大值，则将 `A` 的值更新到 `00H` 中。
  - *`NEXT: DJNZ R1, LOOP`*: `R1` 是数组长度计数器。每处理完一个元素，`R1` 减1。如果 `R1` 还没有减到零，就继续跳转到 `LOOP` 处理下一个元素。当 `R1` 减到零时，表示所有元素都已处理完毕，跳出循环。
  - *`RET`*: 子程序返回。

这个代码段实现了遍历外部RAM数组并找到最大值的功能，并将最大值存储在内部RAM的 `00H` 单元。

== 综合题

AT89C51单片机与RAM芯片6264、ADC0809组成一个数据采集系统。对8路模拟通
道的数据分别采集一次，数据存入内部RAM 40H\~47H单元中。采用中断方式，每次转换
结束向MCU请求INT1中断，在中断服务程序中读取转换结果。设外部中断1采用边沿触
发方式。（要求：对于6264：未用地址均用"0"表示；对于ADC0809：高8位未用地址用
"1"表示，低8位未用地址用"0"表示） 

1. 完善连线及相关地址信息。请将图中AT89C51与两个RAM芯片和ADC0809尚
未连接好的引脚连接好，并根据电路接线图，指出各芯片的地址及其范围（要求对于6264：
未用地址均用"0"表示；对ADC0809：高8位未用地址用"1"表示，低8位未用地址用"0"表
示）： \
i. 完善图中尚未连接好的引脚连接（在答题卷上画线）； \
ii. 数据存储器6264(1)的地址范围为：#underline("       ")； \
iii. 数据存储器6264(2)的地址范围为：#underline("       ")； \
iv. ADC0809的IN0~IN7地址范围为： #underline("       ")；

2.请根据注释编写未完成的程序（请在答题卷上答题）。\
(1)主程序
```asm
ORG 0000H 
       ____
ORG 0013H 
       ____

ORG 0100H 
MAIN:  ____ ; 置外部中断1为下降沿触发
       ____ ; 允许外部中断1 
       ____ ; 开总中断 
       MOV R2, #08H ; 通道数设置 
       MOV R0, #40H ; 数据存储初始地址 
       ____ ; 指向IN0通道 
       ____ ; 建立地址指针
START: CLR F0 ; 清除中断发生标志F0 
       ____ ; 启动ADC0809
LOOP:  JNB F0,  LOOP ; 判断中断发生标志，不为1，则等待 
       ____ ; 8个通道转换没有结束，则循环
       CLR EX1 ; 全部转换结束，关闭中断 
       SJMP $ 
```
(2)中断服务子程序：
```asm
ADINT: PUSH ACC
       ____ ; 读A/D转换结果（1分） 
       ____  ; 存放转换数据（1分） 
       ____ ; 指向下一个地址单元（1分） 
       POP ACC 
       ____  ; 指向下一个通道（1分） 
       SETB F0 ; 置位中断标志 
       ____ ; 中断返回（1分） 
       END
```

*Answer Sheet*

1. 
  ii. 2000H\~3FFFH
  iii. A000H\~BFFFH
  iv. 7F00H\~7F07H

2. 
  - `LJMP MAIN`
  - `LJMP ADINT`
  - `SETB IT1`
  - `SETB EX1`
  - `SETB EA`
  - `MOV A, #00H`
  - `MOV DPTR, #7F00H`
  - `MOVX @DPTR, A`
  - `DJNZ R0, START`

  - `MOVX  A, @DPTR`
  - `MOV @R0, A`
  - `INC R0`
  - `INC A`
  - `RETI`

