#import "../template/conf.typ": conf
#import "../template/components.typ": *
#import "@preview/codly:1.3.0": codly, codly-init
#import "@preview/codly-languages:0.1.8": codly-languages

#show: codly-init
#codly(languages: codly-languages)

#show: conf.with(
  title: [
    微机控制原理 习题
  ],
  authors: (
    (
      name: [Gang.],
      affiliation: [Hangzhou Dianzi University],
      email: "jerry050512@outlook.com",
    ),
  )
)

#set figure(
  numbering: none
)

#show table: it => align(center, it)

#set table(
  fill: (x, y) => if y == 0 {luma(80%)},
  align: center+horizon,
)

= 往年试卷

== 判断题

1. 8051微控制器存储结构RAM、ROM分开编址。
2. 存储器的容量与其地址线数量有关，地址线越多，容量越大。
3. 8051微控制器中工作寄存器R7的实际物理地址与PSW中的内容有关。
4. `MOV SP，#5FH`指令是将堆栈空间设置到内部RAM 60H单元开始。
5. 只有对十进制加法和减法运算，才能进行十进制调整。
6. NOP不会使微控制器产生任何操作，因此属于伪指令。
7. END表示程序指令执行到此结束。
8. 总中断允许位EA被置成“1”后，所有的中断都处于允许状态。
9. 8051微控制器中串行口的中断标志RI, TI，只能用软件进行清零。
10. 8051中的定时器/计数器，其工作方式2不存在定时误差。

*Answer Sheet*

#table(
  columns: 11, 
  [*Number*], [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], 
  [*Answer*], [T], [T], [T], [T], [F], [F], [F], [F], [T], [T]
)

1. 8051的RAM和ROM采用*分开编址*，即分别拥有独立的地址空间。ROM通常用于程序存储（程序存储器），而RAM用于数据存储（数据存储器）。
2. 存储器地址线的数量决定了可以寻址的单元数。若有 $n$ 条地址线，则最多可寻址  $2^n$ 个地址单元，地址线越多，容量越大。
3. 8051中`R0–R7`共有4组寄存器组，存储于RAM `00H–1FH`。实际使用哪组取决于`PSW`寄存器中的`RS1`和`RS0`位的值，因此R7的物理地址确实与PSW有关。
4. `MOV SP, #5FH` 将堆栈指针`SP`设置为`5FH`，那么下一次入栈操作将发生在 `60H`单元。所以可以说堆栈“从`60H`开始”。
5. 8051微控制器中，十进制调整指令`DA A`（Decimal Adjust Accumulator）通常用于BCD码（Binary-Coded Decimal）的加法运算之后，以确保结果是正确的BCD码。它不适用于减法运算。对于减法，通常采用补码运算，不需要十进制调整。
/ BCD码（Binary-Coded Decimal，二进制编码的十进制数）: 一种用4位二进制数来表示1位十进制数字（0\~9）的编码方式。具体来说，每个十进制数字用4个位的二进制数表示，范围从0000（代表0）到1001（代表9），其余6种4位组合（1010到1111）不属于有效编码。
6. `NOP` 是“无操作”指令，*占用一个机器周期执行*，但它是真正的机器指令，在代码中会被编译；伪指令如END不会生成机器代码。
7. *`END` 是伪指令*，用于告诉汇编器源程序到此结束，而不是控制程序运行结束。程序运行结束依赖指令如`SJMP $`或调用`RET`返回等。
8. 设置 `EA=1` 是总中断使能条件，但每个中断源还需其*对应的中断允许位*（如`EX0`、`ET0`等）也被置1才真正允许。因此 `EA=1` 不等于“所有中断都使能”。
9. 串行口的接收中断标志位`RI`（Receive Interrupt）和发送中断标志位`TI`（Transmit Interrupt）在硬件检测到接收完成或发送完成后会自动置1，以产生中断请求。然而，它们不会被硬件自动清零。在中断服务程序中，必须通过软件（例如`CLR RI`和`CLR TI`指令）手动将它们清零，否则将导致重复中断。
10. 8051定时器的工作方式2（8位自动重装载模式）虽然在*理论上可以实现精确的周期定时*，但仍然存在定时误差。这种误差主要来源于以下几个方面：
  - 指令周期误差： 定时器计数是基于机器周期的，而指令的执行需要不同的机器周期数。中断服务程序和主程序的指令执行会占用CPU时间，导致计时不连续。
  - 中断响应时间： 当定时器溢出请求中断时，CPU需要一定的时间来响应中断、保存现场、跳转到中断服务程序。这段时间也是一种误差。
  - 晶振误差： 无论什么工作方式，定时器的精度都依赖于外部晶振的精度。晶振本身可能存在频率偏差。 因此，工作方式2只是相对其他方式而言更方便实现固定周期定时，但并非完全没有误差。

== 选择题

1. 若FEH是有符号数，其代表的数值是#underline("       ")。\  
  A. -1 \
  B. -2 \
  C. -254 \
  D. -127 
2. 在8051MCU中，反映程序运行状态或反映运算结果特征的特殊功能寄存器是#underline("       ")。\ 
  A. `PCB` \
  B. `PSW` \
  C. `A` \
  D. `SP` 
3. 已知`A`的值为`98H`，将其与`0FAH`相加，标志位`Cy`，`AC`，`OV`，`P`的值分别是#underline("       ")。 \
  A. 0,0,0,1 \
  B. 1,0,1,0 \
  C. 1,1,1,1 \
  D. 1,1,0,1 
4. 指令系统中的寻址方式就是#underline("       ")的方式。 \
  A.查找指令操作码 \
  B.查找指令 \
  C.查找指令操作数 \
  D.查找指令操作数与操作码
5. 执行`PUSH A`指令，8051微控制器完成的操作是#underline("       ")。\ 
  A. `(SP)+1→(SP), (A)→((SP))` \
  B. `(A)→((SP)), (SP)-1→(SP)` \
  C. `(SP)-1→(SP), (A)→(SP))` \
  D. `(A)→((SP), (SP)+1→(SP)` 
6. 下列指令中，没有用到8051微控制器堆栈区的是#underline("       ")。 \ 
  A. `LCALL` \
  B. `ADD` \
  C. `PUSH` \
  D. `RET` 
7. 已知`(A)=0DBH`，`(R4)=73H`，`(C)=1`，执行指令`SUBB A, R4`后的结果是#underline("       ")。 \ 
  A. `(A)=73H` \
  B. `(A)=ODBH` \
  C. `(A)=67H` \
  D. 以上都不对 
8. 处于同一级别的5个中断源同时请求中断时，CPU响应中断的次序为#underline("       ")。  \
  A. 串行口、T1、INT1、T0、INT0 \
  B. INT0、T0、INT1、T1、串行口 \ 
  C. 串行口、INT1、T1、INT0、T0 \
  D. T0、INT0、T1、INT1、串行口 
9. 进行BCD码加法运算时，对加法结果进行十进制调整的指令是#underline("       ")。  \
  A. `ADD` \
  B. `ADDC` \
  C. `DA A` \
  D. 由实际程序确定 
10. 8051 MCU的中断源和中断标志位的个数分别为#underline("       ")。 \ 
  A. 5、5 \
  B. 5、6 \
  C. 6、6 \
  D. 6、5 
11. 微控制器响应中断时，保护现场的工作#underline("       ")。 \
  A. 由CPU自动完成 \
  B. 在中断响应时完成 \
  C. 由中断服务程序完成 \
  D. 在主程序中完成 
12. 当8051微控制器响应外部中断0后，`PC`的值是#underline("       ")。 \
  A. `0000H` \
  B. `0003H` \
  C. `000BH` \
  D. `0013H` 
13. 启动定时器1工作的指令是使 `TCON`的#underline("       ")。 \
  A. TF1位置1 \
  B. TR1位置1 \
  C. TR1位置0 \
  D. TR0位置0 
14. 当`T0`工作在定时工作方式1时，其最长定时时间为#underline("       ")。（晶振频率12MHz） \
  A. 65536μs \
  B. 4096μs \
  C. 16384μs \
  D. 8192μs 
15. 假设晶振频率为12MHz，要实现50ms的定时，定时器0的工作方式为1，则初值为 #underline("       ")。 \
  A. `TH0=0CH, TL0=78H` \
  B. `TH0=0ECH, TL0=78H` \
  C. `TH0=3CH, TL0=B0H` \
  D. `TH0=B0H, TL0=3CH` 
16. 8051 微控制器中，定时器/计数器的位数是#underline("       ")。 \
  A. 8位 \
  B. 16位 \
  C. 13位 \
  D. 由工作方式决定的 
17. 异步串行通信中，收发双方必须保持#underline("       ")。 \
  A. 收发时钟相同 \
  B. 系统晶振相同 \
  C. 数据帧格式和波特率相同 \
  D. 以上都正确 
18. 设某12位D/A转换满量程输出电压为5V，此转换器的电压分辨率为#underline("       ")mV。 \
  A. 1.22 \
  B. 2.44 \
  C. 4.88 \
  D. 19.6 
19. 对于数据采集系统，应根据被测量信号的频率，选择ADC的#underline("       ")。 \
  A. 分辨率 \
  B. 转换精度 \
  C. 转换时间 \
  D. 线性度 
20. 利用8051微控制器的UART扩展I/O接口时，应选择工作于#underline("       ")。 \
  A. 并行通信方式 \
  B. 10位异步通信方式 \
  C. 11位异步通信方式 \
  D. 同步移位寄存器输入/输出方式 

*Answer Sheet*

#table(
  columns: 11, 
  [*Number*], [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], 
  [*Answer*], [B], [B], [D], [C], [A], [B], [C], [B], [C], [B], 
  [*Number*], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], 
  [*Answer*], [C], [B], [B], [A], [C], [D], [C], [A], [C], [D], 
)

1. 在计算机中，有符号数通常使用补码表示。
首先，将十六进制数 FEH 转换为二进制：`1111 1110B`。
由于最高位是1，表示这是一个负数。
求其补码的真值：
- 减1：`1111 1110B` - 1 = `1111 1101B`
- 按位取反（求反码）：`0000 0010B`
- 将反码转换为十进制： $2^1 = 2$
所以，`FEH`代表的数值是 $-2$。

2. 
- `PSW` (Program Status Word) 寄存器包含了反映CPU当前工作状态的各种标志位，如进位标志`CY`、辅助进位标志`AC`、溢出标志`OV`、奇偶校验标志`P`以及寄存器组选择位`RS0`和`RS1`。它直接反映了运算结果的特征和程序运行状态。
- `A`是累加器，用于数据运算。
- `SP`是堆栈指针。
- `PCB`不是8051中的标准特殊功能寄存器名称。

3. `A = 98H = 1001 1000B`, `0FAH = 1111 1010B`, 执行加法：
```
  1001 1000   (98H)
+ 1111 1010   (FAH)
-----------
1 1001 0010   (192H)
```
- CY (Carry Flag, D7进位): D7位向外有进位，所以 CY = 1。
- AC (Auxiliary Carry Flag, D3进位): D3位进位，所以 AC = 1。
- OV (Overflow Flag, 溢出): 如果两个正数相加结果为负数，或者两个负数相加结果为正数，则 OV = 1。此处没有溢出. 
- P (奇偶标志): 保证有偶数个1, 此处有3个1, 故P = 1. 

4. / 寻址方式: 指CPU在执行指令时，*寻找操作数所在的地址*的方式。指令的操作码指示了操作的类型，而操作数则是进行操作的数据。寻址方式决定了如何根据指令中的地址信息来获取操作数。

5. 8051的堆栈是向上增长的，即堆栈指针`SP`在数据入栈前先自增，然后将数据存入`SP`指向的新地址。
  - `(SP)+1→(SP)`：堆栈指针先自增1。
  - `(A)→((SP))`：将累加器A中的内容压入到SP指向的（新）地址。

6. 
  - `LCALL` (Long Call)：*调用子程序*指令，会将返回地址*压入堆栈*。
  - `ADD` (Add): 加法指令，*只涉及寄存器和/或存储器之间*的数据操作，不使用堆栈。
  - `PUSH`: 压栈指令，明确地将数据*压入堆栈*。
  - `RET` (Return): 从子程序返回指令，会从堆栈中*弹出返回地址*。

7. `SUBB A, R4`指令的含义是 `A = A - R4 - C`。\
  `(A) = 0DBH` \
  `(R4) = 73H` \
  `(C) = 1` \
  - 计算：`0DBH - 73H - 1`
  - 转换为十进制：`219 - 115 - 1 = 103`
  - 将103转换为十六进制：`103 / 16 = 6` 余 `7`。所以 `103D = 67H`。
  因此，`(A)`的值将是 `67H`。

8. 8051微控制器在中断优先级相同时，会按照固定的查询顺序（内部优先级）来响应中断。这个固定顺序是从高到低依次为：
  `INT0` (外部中断0), 
  `T0` (定时器0), 
  `INT1` (外部中断1), 
  `T1` (定时器1), 
  串行口 (Serial Port)

9. `DA A` (Decimal Adjust Accumulator) 是十进制调整指令，专门用于在执行BCD码加法（无论是ADD还是ADDC）后，将累加器A中的结果调整为正确的BCD码形式。

10. 8051微控制器有5个中断源：
  - 外部中断0 (`INT0`)
  - 定时器/计数器0 (`T0`)
  - 外部中断1 (`INT1`)
  - 定时器/计数器1 (`T1`)
  - 串行口 (`TI` 或 `RI`，被视为一个中断源)
  而对应的中断标志位有6个：
  - `IE0` (外部中断0标志)
  - `TF0` (定时器0溢出标志)
  - `IE1` (外部中断1标志)
  - `TF1` (定时器1溢出标志)
  - `RI` (串行口接收中断标志)
  - `TI` (串行口发送中断标志)
  虽然串行口被视为一个中断源，但它有`RI`和`TI`两个独立的中断标志位。

11. 8051微控制器在响应中断时，CPU自动完成的操作仅仅是将当前的程序计数器 `PC` 的值（即返回地址）压入堆栈，并将 `PC` 设置为中断向量地址。保护现场，即保存其他可能被中断服务程序修改的寄存器（如`A`、`B`、`PSW`、`R0-R7`等）的内容，是由中断服务程序（`ISR`）的编写者通过指令（如`PUSH`指令）来完成的。这是为了确保中断服务程序执行完毕后，主程序能够恢复到中断前的正确状态。

12. 8051微控制器有固定的中断向量地址。当CPU响应外部中断0（`INT0`）后，程序计数器`PC`会自动加载外部中断0的中断向量地址，即`0003H`。
  - `0000H`是复位向量地址。
  - `000BH`是定时器0中断向量地址。
  - `0013H`是外部中断1中断向量地址。

13. `TCON`（Timer Control Register）是定时器/计数器的控制寄存器。其中的 `TR0` 和 `TR1` 位是定时器/计数器的启动/停止控制位。
  - `TR1`（Timer 1 Run Control Bit）：当 TR1 置1时，定时器1开始计数；当 TR1 置0时，定时器1停止计数。
  - `TF1` 是定时器1的溢出标志位，由硬件置1，表示溢出。

14. 
  - 机器周期： 8051在12MHz晶振下，一个机器周期是 
  $ T_m = 12 / (12"MHz") = 1"μs" $
  - 工作方式1： 定时器/计数器0工作在方式1时是16位定时器。这意味着它可以从`0000H`计数到`FFFFH`。
  - 最大计数次数： 
  $ 2^16 = 65536 次 $
  - 最长定时时间： 
  $ "最大计数次数" times "每个机器周期的时间" = 65536 times 1"μs" = 65536"μs" $

15. 
  - 机器周期： 12MHz晶振下，一个机器周期是 1μs。
  - 定时时间转换成机器周期数： 50ms=50000μs。
  - 计数初值计算： 对于16位定时器（方式1），计数器从初值开始递增到`FFFFH`才溢出。
  - 设需要的计数次数为N，则 
  $ N = "定时时间" / "机器周期" = (50 times 10^3"μs") / (1"μs") = 50000 $
  $ "初值" = 65536 - N = 65536 - 50000 = 15536 "(十进制)"$
  - 将初值转换为十六进制：
    - 15536÷256=60 余 176
    - 60D = 3CH
    - 176D = B0H
  所以，初值 `TH0 = 3CH`，`TL0 = B0H`。

16. 8051微控制器内部的定时器/计数器（T0和T1）本质上都是16位的计数器。它们可以被编程为不同的工作方式：
  - 方式0：13位定时器
  - 方式1：16位定时器
  - 方式2：8位自动重装载定时器
  - 方式3：T0分为两个8位定时器，T1停止计数 虽然它们可以在不同的工作方式下表现出8位或13位的功能，但其核心计数寄存器 (`THx` 和 `TLx`) 组合起来始终是16位。

17. 在异步串行通信中：
- 数据帧格式（起始位、数据位、校验位、停止位）必须一致，以便正确地解析数据。
- 波特率（每秒传输的位数）必须相同，这样收发双方才能以相同的速率采样数据，避免误码。
- 收发时钟不一定相同，因为是异步通信，各自有自己的时钟，通过数据同步。
- 系统晶振不一定相同，只要波特率能通过分频或其他方式调整到一致即可。

18. / 分辨率: D/A转换器的分辨率是指它能分辨出的最小输出电压变化量，通常是满量程输出电压除以 $2^N - 1$ 或 $2^N$ （取决于是否包含零）。对于N位D/A转换器，分辨率是 $V_"FS" / (2^N - 1)$ 或 $V_"FS" / 2^N$。在多数计算中，为了简化，通常用 $V_"FS" / 2^N$。
  - 满量程输出电压 $V_"FS"$=5V=5000mV。
  - 位数 N=12。
  - $2^12 = 4096$。
  - 分辨率 = 5000mV/4096≈1.2207mV。

19. 
  - 转换时间：ADC将模拟信号转换为数字信号所需的时间。根据奈奎斯特采样定理，采样频率至少是被测信号最高频率的两倍。因此，ADC的转换时间（或者说采样速率）必须足够快，才能跟上信号频率的变化，避免信号失真。
  - 分辨率：决定了数字输出的精细程度，与信号的幅值范围和测量精度要求有关。
  - 转换精度：衡量转换结果的准确性。
  - 线性度：反映ADC输入/输出关系的线性程度。 
  虽然分辨率、精度和线性度也很重要，但转换时间是直接决定ADC是否能有效采集特定频率信号的关键参数。

20. 8051的UART（通用异步收发器，即串行口）除了用于串行通信外，还可以配置在工作方式0。
  - 工作方式0是同步移位寄存器输入/输出方式。在这种模式下，串行口被用作一个同步移位寄存器，可以方便地进行8位数据的串行输入或输出，常用于扩展并行I/O口（例如驱动LED、读取按键等），因为它提供了同步时钟输出。
  - 10位/11位异步通信方式是用于标准的串行通信。

== 填空题

1. 按使用功能，通常将内部RAM区划分为  #underline("       ")、#underline("       ") 和 #underline("       ") 三个区域。 
2. 微机中的存储器通常采用 #underline("       ") 和普林斯顿两种基本结构形式，采用的两种指令集体系是 #underline("       ") 和精简指令集计算机(RISC)。 
3. 在中断程序中，保护工作寄存器的方法有 #underline("       ") 、 #underline("       ") 和存储器保护。 
4. 设`(A) = 56H`，`(B) = 81H`，请写出执行下述指令后的结果
  ```asm
  ADD  A，B 
  DA   A 
  ```
  (A) = #underline("       ") ；(C) = #underline("       ") ；(P)= #underline("       ") 。 
5. 按照数据传输方向，串口通信可分 #underline("       ") 、 #underline("       ") 和 #underline("       ") 三种基本传送方式。 
6. CPU和外设进行数据交换时，常用的两种方式为 #underline("       ") 、 #underline("       ") 。 

*Answer Sheet*

#table(
  columns: (auto, 1fr), 
  [*Number*], [*Answer*], 
  [1], [工作寄存器区、位寻址区和用户RAM区], 
  [2], [哈佛, 复杂指令集计算机（CISC）],
  [3], [堆栈保护, 切换工作寄存器组保护], 
  [4], [`37H`, `1`, `1`], 
  [5], [单工、半双工和全双工], 
  [6], [查询, 中断]
)

1. 8051微控制器的内部RAM（128字节）根据其功能和寻址方式被划分为三个主要区域：
  - 工作寄存器区 (`00H-1FH`)： 包含`R0-R7`共四组，用于快速数据操作，由`PSW`寄存器选择当前使用的寄存器组。
  - 位/字节寻址区 (`20H-2FH`)： 这16个字节既可以进行字节寻址，也可以进行位寻址，非常适合对单个标志位进行操作。
  - 用户RAM区 (`30H-7FH`)： 作为通用数据存储区，通常用作堆栈区和用户程序的数据存储。

2. 
  - 微机中的存储器结构主要有两种：哈佛结构（程序存储器和数据存储器分开，有独立的地址总线和数据总线）和普林斯顿结构（又称冯·诺依曼结构，程序存储器和数据存储器共用地址总线和数据总线）。8051微控制器内部采用的是哈佛结构。
  - 指令集体系结构主要有两类：复杂指令集计算机(CISC)，其指令集庞大且功能复杂，一条指令可以完成多种操作；以及精简指令集计算机(RISC)，其指令集较小，每条指令功能单一，但执行速度快。8051属于CISC架构。

3. 在中断服务程序中，为了不影响主程序的正常运行，需要保存那些可能被中断程序修改的寄存器内容，这通常称为“保护现场”。主要有两种方法：
  - 堆栈保护： 最常用的方法，通过`PUSH`指令将工作寄存器（`A`, `B`, `PSW`, `R0-R7`等）压入堆栈，在中断服务程序结束前用`POP`指令恢复。
  - 切换寄存器组： 8051有四组`R0-R7`工作寄存器。在中断服务程序的开头，可以通过修改`PSW`寄存器的`RS0`和`RS1`位，切换到另一组未被主程序使用的寄存器组，从而避免覆盖主程序的工作寄存器内容。中断返回前再切换回原来的寄存器组。
  - 存储器保护： 这是指将寄存器内容保存到内部或外部RAM的特定地址。

4. 
- ADD A, B：
  - 56H + 81H = D7H（无符号数：86 + 129 = 215）。
  - 标志位：
    - CY = 0（无进位，215 < 256）。
    - AC = 1（低4位：6H + 1H = 7H，无半进位？实际计算：0110+0001=0111，无进位，AC=0。但调整规则基于AC和CY）。
    注：DA A调整规则依赖AC和CY，但实际计算时需按BCD码逻辑。
- DA A（十进制调整）：
  - 调整规则（针对BCD码加法）：
    - 若低4位 > 9 或 AC = 1，则加06H。
    - 若高4位 > 9 或 CY = 1，则加60H。
  - 此处A = D7H（非BCD码），但按规则：
    - 低4位（7）< 10，但高4位（13）> 9 → 需加60H。
    - 调整后：D7H + 60H = 137H → A = 37H，CY = 1（进位）。
  - 奇偶标志P：37H = 0011 0111（二进制），含5个1（奇数），故P = 1。

5. 串口通信根据数据传输的方向性，可以分为：
  - 单工(Simplex)： 数据只能在一个方向上传输，不能反向。例如，广播。
  - 半双工(Half-duplex)： 数据可以在两个方向上传输，但在同一时间只能在一个方向上传输。例如，对讲机。
  - 全双工(Full-duplex)： 数据可以在两个方向上同时传输。例如，电话。

6. CPU与外设进行数据交换或控制时，主要有以下几种方式：
  - 程序查询方式： CPU不断地查询外设的状态标志，判断外设是否准备好进行数据交换。这种方式简单，但效率低，CPU占用率高。
  - 中断方式： 外设在需要CPU服务时（如数据准备好、操作完成等），向CPU发送中断请求信号，CPU响应中断后暂停当前任务，转去执行中断服务程序。这种方式效率较高，提高了CPU的利用率。
  - DMA方式 (直接存储器存取)： 适用于大量数据的传输。DMA控制器直接在外设和存储器之间传输数据，无需CPU干预，进一步提高了传输效率和CPU利用率。问题中只要求两种常用方式，通常指前两种。

== 简答题

1. 简述CPU的主要组成部分以及各部分的功能。 

#block(height: 10%)

2. 8051单片机中MOV、MOVC、MOVX指令有什区别？分别用在哪些场合?为什么? 

#block(height: 10%)

3. 简述中断的概念。 

#block(height: 10%)

4. 串行异步通信有哪些特点?其数据帧由哪几部分组成? 

#block(height: 10%)

*Answer Sheet*

1. 简述CPU的主要组成部分以及各部分的功能。

CPU（Central Processing Unit），即中央处理器，是计算机系统的核心部件，负责解释计算机指令以及处理计算机软件中的数据。它主要由以下三个部分组成：

- *运算器 (ALU - Arithmetic Logic Unit)：*运算器是CPU的执行单元，负责执行所有的算术运算（如加、减、乘、除）和逻辑运算（如与、或、非、异或、比较）。它是CPU进行数据加工和处理的核心部件。
- *控制器 (Control Unit)：*控制器是CPU的指挥中心，负责协调和控制计算机系统各部件的工作。它根据指令的要求，从存储器中取出指令，并对指令进行译码，然后发出控制信号，指挥运算器、存储器以及输入/输出设备协同工作，完成指令执行的整个过程。
- *寄存器组 (Registers)：*寄存器是CPU内部用于临时存储数据、地址和控制信息的存储单元。它们是CPU处理数据时速度最快的存储区域。常见的寄存器包括累加器（A）、数据指针（DPTR）、程序计数器（PC）、堆栈指针（SP）以及通用工作寄存器（R0-R7）等，它们为CPU提供快速的数据存取能力，极大地提高CPU的运行效率。

2. 8051单片机中MOV、MOVC、MOVX指令有什么区别？分别用在哪些场合？为什么？

在8051单片机中，`MOV`、`MOVC` 和 `MOVX` 是三条功能相似但操作对象和寻址空间截然不同的数据传送指令。

- *MOV (Move Data)：*
    - *功能：*这是一条最常用的数据传送指令，用于在*内部RAM、特殊功能寄存器（SFR）*以及*工作寄存器*之间进行字节数据传送。
    - *寻址空间：*内部数据存储器和特殊功能寄存器。
    - *场合：*
        - 在内部RAM单元之间传递数据。
        - 将常数（立即数）装入寄存器或内部RAM。
        - 读写特殊功能寄存器，如设置定时器初值、配置串行口模式等。
    - *为什么：*`MOV`指令速度快，可以直接访问片内所有的数据存储器和SFR，是8051进行内部数据操作的首选指令。

- *MOVC (Move Code)：*
    - *功能：*这是一条*程序存储器读指令*，用于从*程序存储器（ROM）*中读取数据到累加器A。指令中的`C`表示"Code"（代码），强调其数据源是程序存储器。
    - *寻址空间：*程序存储器。它使用累加器A和数据指针DPTR（或程序计数器PC）共同构成16位地址。
    - *场合：*
        - 读取查表数据：程序中存储的表格、字符常数、汉字字模等。
        - 作为常数表使用：例如，存储LED显示码表、中断向量表等。
    - *为什么：*8051的程序存储器和数据存储器是分开编址的（哈佛结构）。`MOVC`是唯一能够访问程序存储器中数据的指令，通过DPTR或PC作为基地址，A作为偏移量，可以实现对程序存储器内容的灵活读取。

- *MOVX (Move External Data)：*
    - *功能：*这是一条*外部数据存储器读写指令*，用于在*累加器A*和*外部RAM*之间进行字节数据传送。指令中的`X`表示"External"（外部）。
    - *寻址空间：*外部数据存储器。它可以进行8位（P0口作为地址/数据复用）或16位（P0口作数据，P2口作高8位地址）寻址。
    - *场合：*
        - 扩展外部RAM：当片内RAM不够用时，用于读写外部扩展的RAM芯片。
        - 访问具有RAM接口的外设：如外部ADC/DAC芯片等。
    - *为什么：*8051的外部RAM和内部RAM是分开的，需要专门的控制信号（如`/WR`、`/RD`、`/PSEN`）和总线操作来访问。`MOVX`指令提供了这些必要的控制时序，使其能够与外部存储器进行数据交换。

3. 简述中断的概念。

*中断*是指CPU在执行程序的过程中，遇到外部（如键盘输入、定时器溢出、串口接收等）或内部（如除数为零、非法指令等）的紧急事件或请求时，暂停当前正在执行的程序，转去处理该紧急事件或请求，待处理完毕后再返回到原程序被中断的地方继续执行的一种机制。

*主要特点：*

- *非同步性：*中断的发生是随机的，不与CPU正在执行的程序同步。
- *异步处理：*中断允许CPU在不影响主程序连续性的前提下，及时响应并处理突发事件。
- *提高效率：*通过中断，CPU无需持续查询外设状态，可以做更多有效的工作，当外设需要服务时再响应，大大提高了CPU的利用率和系统的实时响应能力。
- *保护现场与恢复现场：*为了在中断处理完毕后能正确返回主程序，CPU在响应中断时会自动保存程序计数器（PC），而中断服务程序则需要程序员编写代码来保存其他关键寄存器的内容（保护现场），并在返回前恢复（恢复现场）。

4. 串行异步通信有哪些特点？其数据帧由哪几部分组成？

串行异步通信是一种数据传输方式，其特点是不需要收发双方提供同步时钟信号，而是通过约定好的数据帧格式和波特率来实现数据的可靠传输。

*主要特点：*

1.  *无同步时钟线：*收发双方各自使用独立的内部时钟，通过数据帧中的起始位实现同步。
2.  *传输效率相对较低：*因为每一帧数据都需要额外的起始位和停止位来标记开始和结束，增加了传输的开销。
3.  *实时性要求不高：*适用于对实时性要求不严格、传输距离相对较远的应用场景。
4.  *成本低廉：*只需要两根或三根线（数据发送、数据接收和地线）即可实现通信。
5.  *灵活性高：*允许两端设备使用不同的晶振频率，只要能通过分频等方式得到相同的波特率即可。

*数据帧的组成部分：*

一个典型的串行异步通信数据帧通常由以下几部分组成：

1.  *空闲位：*在没有数据传输时，数据线通常保持在高电平状态，这被称为空闲位。
2.  *起始位 (Start Bit)：*始终是一个低电平位。它标志着一帧数据传输的开始，并用于接收端与发送端时钟的同步。
3.  *数据位 (Data Bits)：*实际要传输的数据，通常为5位、6位、7位或8位。最不常用的组合是9位数据位（常见于8051的串行通信方式2和3）。数据位通常是低位在前，高位在后（LSB-first）。
4.  *奇偶校验位 (Parity Bit，可选)：*用于数据传输的错误检测。可以是奇校验（使1的个数为奇数）或偶校验（使1的个数为偶数）。如果不使用校验，则没有此位。
5.  *停止位 (Stop Bit)：*始终是一个高电平位。它标志着一帧数据的结束，并为下一帧数据的起始位做好准备。可以是1位、1.5位或2位停止位，最常用的是1位停止位。

数据帧的典型顺序是：`空闲位 -> 起始位 -> 数据位 -> [校验位] -> 停止位 -> 空闲位`。

== 程序阅读题

1. 阅读下面的子程序段
  ```asm
  SUB1: ADD A, #99H 
        DA  A 
        RET
  ```
  i. 该子程序的主要功能：#underline("       ")。 \
  ii. 如果A=56H，该子程序调用结束后，A=#underline("       ")H； \
    如果A=23H，该子程序调用结束后，A=#underline("       ")H。

2. 阅读下面的子程序段
  ```asm
  SUB1: MOV  R0,  #30H 
        MOV  R1,  #50H 
        MOV  R3,  #08H 

  LOOP: MOV  A,   @R0 
        MOV  @R1, A 
        INC  R0 
        INC  R1 
        DJNZ R3,  LOOP 
        RET 
  ```
  i. 该子程序段的主要功能：#underline("       ")。 \
  ii. 该子程序运行结束后，(R0)= #underline("       ") H,  ( R1)= #underline("       ") H,  (R3)= #underline("       ") H。

3. 阅读程序并填空，代码功能为找到DPTR所指向外部RAM数组中最大的值，数组长度
记录在R1中。
  ```asm
  SUB3:  MOV  00H,  #00H 
  LOOP:  ____ A,    @DPTR 
        ____ DPTR 
        CLR  ____  
        CJNE A,    00H,  testC 
  testC: ____ NEXT 
        MOV  00H,  A 
  NEXT:  DJNZ ____, LOOP 
        RET
  ```

*Answer Sheet*

1. 
  i. 按照压缩的BCD码表示的十进制数对累加器A的值加99 \
  ii. 55; 22;

i. 该子程序的主要功能： 实现累加器A与99H的BCD码加法运算。

解析：

- `ADD A, #99H`：这是一条二进制加法指令，将立即数99H（十六进制）与累加器A中的内容进行二进制相加，结果存回A。
- `DA A`：这是一条十进制调整指令。它通常在执行完BCD码加法（ADD或ADDC）后使用，用于将累加器A中的二进制结果调整为正确的BCD（Binary-Coded Decimal）码格式。
- `RET`：子程序返回指令。
综合来看，这个子程序的核心目的是对A中的一个BCD码数和99H这个BCD码数进行十进制加法运算。

ii. 如果A=56H，该子程序调用结束后，A= 55H；
如果A=23H，该子程序调用结束后，A= 22H。

解析：

- 情况一：A = 56H
  - `ADD A, #99H`：
    - A = 56H (二进制 0101 0110B)
    - 99H (二进制 1001 1001B)
    - 二进制相加：
    ```
      0101 0110 (56H)
    + 1001 1001 (99H)
    ------------
      1110 1111 (EFH)
    ```
    此时 A = EFH。
  - `DA A`：对 EFH 进行BCD调整。
    - EFH 的低四位是 FH (即 1111B)，大于9。根据DA A规则，A的低四位若大于9或AC=1，则A的低四位加06H。
      - EFH + 06H = F5H (二进制 1111 0101B)
    - F5H 的高四位是 FH (即 1111B)，大于9。根据DA A规则，A的高四位若大于9或CY=1，则A的高四位加60H。
      - F5H + 60H = 155H。结果的低8位为 55H。
      - 由于最高位有进位，CY标志位会置1。
    - 所以，最终 A = 55H。

  从十进制角度看：56 (BCD) + 99 (BCD) = 155 (BCD)。由于8051的累加器是8位的，只能保存155的低两位，即55，而高位1则反映在CY标志位上。

- 情况二：A = 23H
  - `ADD A, #99H`：
    - A = 23H (二进制 0010 0011B)
    - 99H (二进制 1001 1001B)
    - 二进制相加：
    ```asm
      0010 0011 (23H)
    + 1001 1001 (99H)
    ------------
      1011 1100 (BCH)
    ```
    此时 A = BCH。
  - `DA A`：对 BCH 进行BCD调整。
    - BCH 的低四位是 CH (即 1100B)，大于9。根据DA A规则，A的低四位若大于9或AC=1，则A的低四位加06H。
      - BCH + 06H = C2H (二进制 1100 0010B)
    - C2H 的高四位是 CH (即 1100B)，大于9。根据DA A规则，A的高四位若大于9或CY=1，则A的高四位加60H。
      - C2H + 60H = 122H。结果的低8位为 22H。
      - 由于最高位有进位，CY标志位会置1。
  - 所以，最终 A = 22H。
  从十进制角度看：23 (BCD) + 99 (BCD) = 122 (BCD)。同样，累加器只能保存低两位22，高位1反映在CY标志位上。

2. 
  i. 将内部RAM 30H开始的8个操作数移动到内部RAM 50H开始的存储器空间 \
  ii. 38,  58, 00

i. 该子程序段的主要功能：*将内部RAM从30H开始的8个字节数据块复制到从50H开始的内存区域。*

*解析：*

  - `MOV R0, #30H`：初始化寄存器 `R0` 为源地址指针，指向内部RAM的 `30H` 单元。

  - `MOV R1, #50H`：初始化寄存器 `R1` 为目的地址指针，指向内部RAM的 `50H` 单元。

  - `MOV R3, #08H`：初始化寄存器 `R3` 为循环计数器，设定为 `8`，表示将复制8个字节的数据。

  - *`LOOP:`*(循环开始标记)

      - `MOV A, @R0`：将 `R0` 指向的内存单元（源地址）中的数据传送到累加器 `A`。
      - `MOV @R1, A`：将累加器 `A` 中的数据传送到 `R1` 指向的内存单元（目的地址）。
      - `INC R0`： `R0` 自增1，使其指向下一个源地址。
      - `INC R1`： `R1` 自增1，使其指向下一个目的地址。
      - `DJNZ R3, LOOP`： `R3` 减1，如果 `R3` 不为零，则跳转到 `LOOP` 标签处继续执行；如果 `R3` 为零，则跳出循环。

  - `RET`：子程序返回。

结合所有指令，该子程序的功能是从内部RAM的 `30H` 地址开始，将8个字节的数据块复制到内部RAM的 `50H` 地址开始的区域。这是一个典型的内存块复制操作。

ii. *该子程序运行结束后，(R0)=38H, (R1)=58H, (R3)=00H*。

*解析：*

  - *R0：*初始值为 `30H`。在循环中，每次复制一个字节后 `R0` 都会 `INC`（自增）一次。循环执行了8次（由 `R3` 控制）。
      - 最终 `R0` 的值为 `30H + 8 = 38H`。
  - *R1：*初始值为 `50H`。与 `R0` 类似，每次复制后 `R1` 也会 `INC`（自增）一次。循环执行了8次。
      - 最终 `R1` 的值为 `50H + 8 = 58H`。
  - *R3：*初始值为 `08H`。`DJNZ` 指令每次循环都会使 `R3` 减1。当 `R3` 减到 `00H` 时，循环结束。
      - 最终 `R3` 的值为 `00H`。

3. `MOVX`, `INC`, `C`, `JC`, `R1`

```asm
SUB3:   MOV  00H,  #00H
LOOP:   MOVX A,    @DPTR  ; 从DPTR指向的外部RAM读取数据到A
        INC  DPTR        ; DPTR自增，指向下一个外部RAM单元
        CLR  C           ; 清除进位标志C，为CJNE指令的比较做准备
        CJNE A,    00H,  testC ; 比较A和00H单元的内容，如果A > 00H，则C=0。如果 A < 00H，则C=1。
testC:  JC  NEXT         ; 如果 C=1 (即 A < (00H))，则跳转到NEXT（不更新）
                          ; 如果 C=0 (即 A >= (00H))，则不跳转，执行MOV 00H, A
        MOV  00H,  A     ; 将A的值（当前最大值）保存到00H单元
NEXT:   DJNZ R1,   LOOP  ; R1减1，如果R1不为零，则跳转到LOOP继续循环
        RET
```

*解析：*

这个子程序的目标是从DPTR指向的外部RAM数组中找到最大的值，并将这个最大值存储在内部RAM的 `00H` 单元中。`R1` 寄存器存储了数组的长度，即需要比较的元素个数。

  - *`MOV 00H, #00H`*: 初始化 `00H` 单元为 `00H`。这个单元将用来存放当前找到的最大值。假设数组中的值都是非负数，初始为0是一个合理的起点。
  - *`LOOP: MOVX A, @DPTR`*: 这是从*外部RAM*读取数据的指令。因为数组在外部RAM中，所以使用 `MOVX`。它将 `DPTR` 指向的外部RAM中的数据读到累加器 `A`。
  - *`INC DPTR`*: 读取一个数据后，`DPTR` 需要自增1，指向数组中的下一个元素，以便下次循环读取。
  - *`CLR C`*: 在使用 `CJNE` 指令比较时，`CJNE` 指令会影响 `C` 标志位。通常 `CJNE A, #data, rel` 如果 `A < #data`，则 `C=1`；如果 `A > #data`，则 `C=0`。如果 `A = #data`，则 `C` 不变。为了正确判断 `A` 是否大于 `00H` 中的当前最大值，需要先清除 `C` 标志位。
  - *`CJNE A, 00H, testC`*: 这条指令比较累加器 `A` 的内容和内部RAM单元 `00H` 的内容。
      - 如果 `A` *不等于*`00H`，则跳转到 `testC`。
      - 如果 `A` *等于*`00H`，则不跳转，直接执行下一条指令（即 `JNC NEXT`）。
  - *`testC: JNC NEXT`*: 这条指令利用了 `CJNE` 指令对 `C` 标志位的影响来判断大小。
      - `JC NEXT` (Jump if No Carry)：如果 `C = 1`，则跳转到 `NEXT`。
      - 结合 `CJNE A, 00H, testC`：
          - 如果 `A > 00H`，则 `CJNE` 会使 `C = 0`。此时 `JC NEXT` *不跳转*，执行 `MOV 00H, A`，更新最大值。
          - 如果 `A < 00H`，则 `CJNE` 会使 `C = 1`。此时 `JC NEXT` *跳转*，执行 `MOV 00H, A`，不更新最大值。 
  - *`MOV 00H, A`*: 如果当前读取的 `A` 的值大于 `00H` 中存放的当前最大值，则将 `A` 的值更新到 `00H` 中。
  - *`NEXT: DJNZ R1, LOOP`*: `R1` 是数组长度计数器。每处理完一个元素，`R1` 减1。如果 `R1` 还没有减到零，就继续跳转到 `LOOP` 处理下一个元素。当 `R1` 减到零时，表示所有元素都已处理完毕，跳出循环。
  - *`RET`*: 子程序返回。

这个代码段实现了遍历外部RAM数组并找到最大值的功能，并将最大值存储在内部RAM的 `00H` 单元。

== 综合题

AT89C51单片机与RAM芯片6264、ADC0809组成一个数据采集系统。对8路模拟通
道的数据分别采集一次，数据存入内部RAM 40H\~47H单元中。采用中断方式，每次转换
结束向MCU请求INT1中断，在中断服务程序中读取转换结果。设外部中断1采用边沿触
发方式。（要求：对于6264：未用地址均用"0"表示；对于ADC0809：高8位未用地址用
"1"表示，低8位未用地址用"0"表示） 

1. 完善连线及相关地址信息。请将图中AT89C51与两个RAM芯片和ADC0809尚
未连接好的引脚连接好，并根据电路接线图，指出各芯片的地址及其范围（要求对于6264：
未用地址均用"0"表示；对ADC0809：高8位未用地址用"1"表示，低8位未用地址用"0"表
示）： \
i. 完善图中尚未连接好的引脚连接（在答题卷上画线）； \
ii. 数据存储器6264(1)的地址范围为：#underline("       ")； \
iii. 数据存储器6264(2)的地址范围为：#underline("       ")； \
iv. ADC0809的IN0~IN7地址范围为： #underline("       ")；

2.请根据注释编写未完成的程序（请在答题卷上答题）。\
(1)主程序
```asm
ORG 0000H 
       ____
ORG 0013H 
       ____

ORG 0100H 
MAIN:  ____ ; 置外部中断1为下降沿触发
       ____ ; 允许外部中断1 
       ____ ; 开总中断 
       MOV R2, #08H ; 通道数设置 
       MOV R0, #40H ; 数据存储初始地址 
       ____ ; 指向IN0通道 
       ____ ; 建立地址指针
START: CLR F0 ; 清除中断发生标志F0 
       ____ ; 启动ADC0809
LOOP:  JNB F0,  LOOP ; 判断中断发生标志，不为1，则等待 
       ____ ; 8个通道转换没有结束，则循环
       CLR EX1 ; 全部转换结束，关闭中断 
       SJMP $ 
```
(2)中断服务子程序：
```asm
ADINT: PUSH ACC
       ____ ; 读A/D转换结果（1分） 
       ____  ; 存放转换数据（1分） 
       ____ ; 指向下一个地址单元（1分） 
       POP ACC 
       ____  ; 指向下一个通道（1分） 
       SETB F0 ; 置位中断标志 
       ____ ; 中断返回（1分） 
       END
```

*Answer Sheet*

1. 
  ii. 2000H\~3FFFH
  iii. A000H\~BFFFH
  iv. 7F00H\~7F07H

2. 
  - `LJMP MAIN`
  - `LJMP ADINT`
  - `SETB IT1`
  - `SETB EX1`
  - `SETB EA`
  - `MOV A, #00H`
  - `MOV DPTR, #7F00H`
  - `MOVX @DPTR, A`
  - `DJNZ R0, START`

  - `MOVX  A, @DPTR`
  - `MOV @R0, A`
  - `INC R0`
  - `INC A`
  - `RETI`

= PPT 习题

== 模拟接口

#rect[(判断) A/D 转换器的精度决定了其量化误差. 

- 错]

量化误差是A/D转换器（模数转换器）固有的误差，源于将连续模拟信号离散化为有限数字值时产生的近似误差。它主要由转换器的分辨率（即位数）决定，而非精度。

- 量化误差的计算：对于一个 $n$ 位的A/D转换器，量化误差通常为$±1/2"LSB"$（最低有效位），其中 
  $ "LSB" = V_"fs" / 2^N $
  $V_"fs"$为满量程电压

- 精度与量化误差的关系：精度是A/D转换器的综合性能指标，包括量化误差、非线性误差、偏移误差、增益误差等多种因素。精度描述了整体转换准确性，而量化误差只是影响精度的一个组成部分。因此，精度不“决定”量化误差；相反，量化误差是影响精度的重要因素之一。
总结：量化误差由分辨率（位数）直接决定，而精度是更宽泛的概念，二者是因果关系而非决定关系。

#rect[(填空) A/D转换器的电压分辨率与`____`, `____`有关. 

- ADC位数, 满量程电压]

A/D转换器的​​电压分辨率​​（即最小可分辨的电压变化量）由以下两个因素决定：

- ADC位数（$N$）​​：位数越高，分辨率越高。例如，10位ADC的分辨率高于8位ADC。
- ​满量程电压($V_"FS"$): 满量程电压越大，相同位数下的分辨率越低（因为量化单位  $V_"FS" / 2^N$变大）。
因此，电压分辨率的计算公式为：
$ "电压分辨率" = V_"FS" / 2^N $

#rect[
  (填空) DAC0832满量程输出电压为5V, 当输入的二进制数变化1bit时, 对应的输出电压变化为`____`. 

  - 19.5mV
]

DAC0832 是一款 8 位 DAC。当输入的二进制数变化 1 位时，输出电压的变化量由*满量程电压*和 *DAC 位数*决定。

DAC0832 的满量程输出电压为 5V，且它是 8 位 DAC。所以，它能分辨的最小电压变化量（即对应的输出电压变化 1 bit）为：

$ "电压分辨率" = V_"FS" / 2^N = (5"V") / 2^8 = 19.53"mV" $

因此，当输入的二进制数变化 1 bit 时，对应的输出电压变化约为 19.5mV。

#rect[
  (判断) 在需要多路DAC0832同步转换的系统中, 这些DAC0832应工作在双缓冲方式. 
  - 对
]

在需要多路 DAC0832 同步转换的系统中，让这些 DAC0832 工作在双缓冲方式是正确的选择。

/ 双缓冲方式（Dual Buffer Mode）: 允许你先将数据写入 DAC0832 的输入寄存器，而此时输出并不会立即改变。只有当一个公共的加载信号（如 #overline("WR2") 信号）到来时，所有 DAC 的输入寄存器中的数据才会同时被传输到 DAC 寄存器，从而使得所有 DAC 的输出电压在同一时刻发生更新。

#rect[
  D/A转换器的分辨率仅仅与其转换位数有关.
  - 对
]

D/A 转换器（DAC）的分辨率确实仅仅与其转换位数有关。分辨率表示 DAC 能够将模拟输出信号分割成多少个离散的电平。一个 $N$ 位的 DAC 可以产生 $2^N$ 个不同的输出电平。位数越多，DAC 的分辨率越高，输出模拟信号的步进越小，越能精确地表示数字输入。

#rect[
  在计算机泖系统中监测温度, 压力等参数需要使用`____`.
  - A/D转换器
]

在计算机监控系统中，为了监测温度、压力等模拟量参数，需要使用 A/D 转换器（ADC）。

这是因为计算机只能处理数字信号，而温度、压力等物理量传感器输出的通常是连续变化的模拟电压或电流信号。ADC 的作用就是将这些连续的模拟信号转换成计算机能够识别和处理的离散的数字信号。经过 ADC 转换后，计算机才能对这些参数进行存储、分析、显示和控制. 

== 串行口

#rect[
  RS485 采用的是半双工方式，因此收发不能同时进行. 
  - 对
]

RS485 采用的是*半双工*通信方式。这意味着数据可以*在两个方向上传输*，但同一时刻只能在一个方向上传输。因此，RS485 在进行数据传输时，发送和接收*不能同时进行*。设备需要轮流发送和接收数据。

#rect[
  RS232 通信传送的信号为的信号为 `____`. RS485 通信传送的信号为 `____`.
  - 数字信号, 差分信号
]

- RS232 通信传送的信号为*数字信号*（或称为单端信号）。它使用相对于公共地线的电压差来表示逻辑“0”和“1”。例如，通常正电压表示逻辑“0”，负电压表示逻辑“1”。
- RS485 通信传送的信号为*差分信号*。它使用两根线（A 和 B）之间的电压差来表示数据。这种差分传输方式具有*更好的抗噪声能力和更远的传输距离*，因为噪声会同时影响两条线，但不会改变它们之间的电压差。

#rect[
  8051 制器串行口的方式 2 和方式 3 ，在接受数据帧时其顺序为 \
  (1) 接收起始位 (2)接收低位到高位的8bit 数据位 (3)接收停止位 (4)接收校验位
  - 1 2 4 3
]

对于 8051 微控制器串行口的方式 2 和方式 3，在接收数据帧时，其正确的顺序是：

- 接收起始位：这是数据帧的第一个位，通常是逻辑“0”，用于同步接收器。
- 接收低位到高位的 8-bit 数据位：在起始位之后，8 位数据（从最低位到最高位）被逐位接收。
- 接收校验位：在数据位之后，会接收一个用于错误检测的校验位（通常是奇偶校验位）。
- 接收停止位：数据帧的最后一个位，通常是逻辑“1”，表示一帧数据的结束。
因此，正确的顺序是 `1-2-4-3`。

让我们逐一看看不同方式的接收顺序：

方式 0 (Shift Register Mode)

- 特点： 8 位数据传输，波特率固定为 $f_"OSC"/12$，没有起始位、停止位和校验位。主要用于扩展并行I/O口或高速数据传输。
- 接收顺序： 只有 8 位数据位。

方式 1 (10-bit UART Mode)

- 特点： 10 位数据帧，包括 1 位起始位、8 位数据位和 1 位停止位。波特率可变，通过定时器 1 的溢出率和 SMOD 位来设定。这是最常用的 UART 工作方式。
- 接收顺序：
  + 接收起始位 (逻辑“0”)
  + 接收 8 位数据位 (从低位到高位)
  + 接收停止位 (逻辑“1”)

方式 2 (11-bit UART Mode with Auto Baud Rate)

- 特点： 11 位数据帧，包括 1 位起始位、8 位数据位、1 位第九位数据（通常用作校验位或多机通信地址位）和 1 位停止位。波特率固定为 $f_"OSC"/32$ 或 $f_"OSC"/64$（取决于 PCON 寄存器中的 SMOD 位）。
- 接收顺序：
  + 接收起始位 (逻辑“0”)
  + 接收 8 位数据位 (从低位到高位)
  + 接收第 9 位数据 (可以是校验位或地址位)
  + 接收停止位 (逻辑“1”)

方式 3 (11-bit UART Mode with Variable Baud Rate)

- 特点： 与方式 2 类似，也是 11 位数据帧，包含 1 位起始位、8 位数据位、1 位第九位数据和 1 位停止位。但其波特率可变，与方式 1 的波特率计算方式相同（通过定时器 1 溢出率和 SMOD 位设定）。
- 接收顺序：
  + 接收起始位 (逻辑“0”)
  + 接收 8 位数据位 (从低位到高位)
  + 接收第 9 位数据 (可以是校验位或地址位)
  + 接收停止位 (逻辑“1”)

#rect[
  8051 MCU 向 SBUF 发一个数据， 是启动串行口的发送. 因此读SBUF是串行的接收. 
  - 错
]

这里存在一个误解。在 8051 微控制器中：

- 向 SBUF 写入数据确实是启动串行口的发送。当您将一个字节的数据放入 SBUF 寄存器时，8051 的串行通信硬件就会开始将这个字节通过 TxD 引脚发送出去。
- 从 SBUF 读取数据是获取串行口接收到的数据。当 8051 的串行口通过 RxD 引脚接收到一个完整的数据帧后，接收到的数据字节会自动存入 SBUF 寄存器，等待 CPU 读取。
因此，SBUF 是一个双功能寄存器：写入它用于发送，而读取它用于接收。两者功能不同，但都操作同一个 SBUF 寄存器。

#rect[
  异步串行通信的波特率决定了数据通信的速率。
  - 对
]

异步串行通信的波特率确实决定了数据通信的速率。
/ 波特率: 是指每秒钟传输的符号（或信号变化）的数量。在许多情况下，尤其是在简单的串行通信中，一个符号代表一个比特。因此，更高的波特率意味着每秒传输的比特数更多，数据通信的速度也就越快。

#rect[
  波特率反映了数据传递的速率，一般用`____`表示.
  - 位/秒
]

波特率反映了数据传递的速率，通常用*位/秒（bits per second, bps）*表示。尽管技术上“波特”指的是每秒传输的符号数，而“位/秒”指的是每秒传输的比特数，但在多数简单的异步串行通信场景下，一个符号就对应一个比特，所以这两个单位可以互换使用。

#rect[
  在异步串行通信中，发送与接收可以同时进行的通信方式，称为`____`传送方式.
  - 全双工
]

在异步串行通信中，发送与接收可以同时进行的通信方式，称为*全双工（Full-Duplex）*传送方式。

- *全双工*允许通信双方在同一时间独立地发送和接收数据，就像打电话一样，你可以边说边听。
- *半双工（Half-Duplex）*则只允许数据在同一时间向一个方向传输，就像对讲机一样，你需要轮流说话和听。
- *单工（Simplex）*只允许数据在一个固定方向传输，例如广播。

== 定时器

#rect[
  在每个循环中，高电平时间为 1 $mu"s"$, 低电平时间为 3$mu"s"$, 周期是 4$mu"s"$，占空比为？
  - $ 1/4 $
]

/ 占空比: 方波信号中高电平持续时间与整个周期时间之比。

- 高电平时间 = 1μs
- 低电平时间 = 3μs
$ "周期" = "高电平时间" + "低电平时间" = 1"μs" + 3"μs" = 4"μs" $
因此，占空比为：
$ "占空比" = "高电平时间" / "低电平时间" = (1 mu"s") / (4 mu"s") = 1 / 4 $

#rect[
  不论工作在何种方式下 8051 微控制器定时器/计数器的计数初值仅在初始化设置即可.
  - 错
]

8051 微控制器定时器/计数器的计数初值并不仅仅在初始化时设置一次即可。

- 作为定时器时：当定时器溢出后，它会从 `00H` 重新开始计数。为了实现精确的定时，通常需要在每次溢出中断发生后，重新装载计数初值。
- 作为计数器时：每当外部事件发生时，计数器会加 1。如果需要统计一定数量的外部事件，或者在计数完成后重新开始计数，也需要在适当的时候重新设置其计数初值。
所以，计数初值常常需要在每次计时或计数周期结束后重新装载。

#rect[
  8051微控制器 T0 用作计数器，采用工作方式2则其最大的计数值为 256 .
  - 对
]

8051 微控制器 T0（定时器/计数器 0）用作计数器时，工作方式 2 是 8 位自动重装载模式。

- 在这种模式下，`TH0`（定时器 0 高字节）寄存器用于存储预设的重载值。
- `TL0`（定时器 0 低字节）寄存器作为计数器，从装载值开始向下计数，当 `TL0` 从 `FFH` 变为 `00H` 时，会产生溢出，并且 `TL0` 会自动从 `TH0` 中装载的值重新开始计数。
由于 TL0 是一个 8 位寄存器，它可以从 `00H` 计数到 `FFH`，这表示它可以计数 256 个脉冲（从 0 到 255）。因此，其最大的计数值为 256。

*拓展*

8051 微控制器有两个 16 位定时器/计数器，通常称为 Timer 0 (T0) 和 Timer 1 (T1)。它们可以独立配置为四种工作方式中的任何一种。

以下是它们作为计数器时的最大计数值：

1. 方式 0 (Mode 0)
   - 结构：13位计数器
   - 组成：由THx的全部8位和TLx的低5位组成（x=0或1），TLx高3位未用
   - 计数范围：0000H到1FFFH
   - 最大计数值：$2^13=8192$
   - 特点：8051家族早期兼容模式，现已较少使用

2. 方式 1 (Mode 1)
   - 结构：16位计数器
   - 组成：THx(高8位)和TLx(低8位)组成16位寄存器
   - 计数范围：0000H到FFFFH
   - 最大计数值：$2^16=65536$
   - 特点：最常用灵活的工作方式，可实现大范围定时/计数，溢出需软件重装初值

3. 方式 2 (Mode 2)
   - 结构：8位自动重装载计数器
   - 组成：TLx作为8位计数器，THx存储重装载值
   - 计数范围：00H到FFH
   - 最大计数值：$2^8=256$
   - 特点：TLx溢出时THx值自动重装，无需软件干预，适合周期性精确计数

4. 方式 3 (Mode 3)
   - 特点：
     - 对T0：分成两个独立8位计数器
       - TL0：使用T0控制位(C/T0,GATE0,TR0,TF0)和溢出标志
       - TH0：使用T1控制位(TR1,TF1)，不生成中断
     - 对T1：当T0工作在方式3时会被"禁用"
       - 只能保留方式0/1/2的值
       - 不能独立运行
       - TF1和TR1会被TH0"借用"
   - 最大计数值：两个独立8位计数器(各256)
   - 应用场景：需要额外8位定时器且可牺牲T1独立功能时使用

#rect[
  MCS-51 微控制器定时/计数器采用的如下哪一种？
  - 加法器结构
]

MCS-51 微控制器定时/计数器采用的是加法器结构。

这意味着定时器/计数器在每个机器周期（作为定时器）或每个外部脉冲（作为计数器）到来时，其内部的值会递增（加 1）。当计数值达到最大值后溢出，并从预设的初值或 0 重新开始计数。这种递增计数的方式是典型的加法器结构。

== 中断系统

#rect[
  由于各中断入口地址的间隔只有 8 个单元，因此经常在中断入口地址后放`____`. 
  - `LJMP`或`SJMP`指令
]

由于 8051 微控制器中各个中断入口地址的间隔只有 8 个字节，这个空间通常不足以编写完整的中断服务程序。为了解决这个问题，我们通常在中断入口地址处放置一条跳转指令，如 `LJMP` (长跳转) 或 `SJMP` (短跳转)。这条指令会将程序流导向中断服务程序的实际起始地址，而中断服务程序本身可以存放在内存的任何位置。

#rect[
  8051 微控制器执行 `RETI` 指令后`____`
  - 回到响应中断时的下一条指令
]

8051 微控制器执行 `RETI` (Return from Interrupt) 指令后，程序会回到响应中断时的下一条指令继续执行。

RETI 指令不仅仅是简单地返回，它还负责：
- 弹出中断发生时压入堆栈的程序计数器 (`PC`) 的值，使程序返回到中断点。
- 恢复中断系统，允许更高或同级的中断再次被响应（如果它们被使能）。这是 `RETI` 与普通返回指令 `RET` 的主要区别。

#rect[
  微控制器响应中断时，保护现场的工作`____`
  - 由中断服务程序完成
]

微控制器响应中断时，*保护现场的工作由中断服务程序完成*。

当微控制器检测到中断并响应时，硬件会自动将当前的程序计数器 (`PC`) 压入堆栈，以便中断服务程序执行完毕后能返回到正确的位置。然而，除了 `PC` 之外，许多其他寄存器（如累加器 `ACC`、`B` 寄存器、`PSW` 寄存器等）中的数据也可能被中断服务程序修改。为了确保主程序在中断返回后能正确继续执行，中断服务程序必须手动将它会使用到的这些寄存器内容压入堆栈进行保存，并在返回前恢复它们。这部分操作就是我们所说的“保护现场”。

#rect[
  8051 CPU开中断的指令是`____`
  - `SETB EA`
]

8051 CPU 开中断的指令是 `SETB EA`。

- `EA` (Enable All) 是 8051 中断允许寄存器 `IE` (Interrupt Enable) 的最高位（IE.7）。
- 当 `EA` 位设置为 1 (`SETB EA`) 时，表示总中断允许，允许 CPU 响应外部中断请求。
- 如果 `EA` 位设置为 0 (`CLR EA`)，则表示总中断禁止，所有中断请求都会被屏蔽，即使某个特定的中断源被允许。
要使某个具体的中断源生效，除了 `SETB EA` 之外，还需要设置对应中断源的独立允许位（例如，要使能外部中断 0，需要设置 IT0 位；要使能定时器 0 中断，需要设置 ET0 位）。

== MCS-51 系统扩展

#rect[
  下列中，不属于8051微控制器存储器系统特点的是() \
  A. 程序和数据两种类型的存储器同时存在 \
  B. 芯片内外存储器同时存在 \
  C. 扩展存储器与片内数据存储器存储空间重叠 \
  D. 扩展程序存储器与片内程序存储器存储空间重叠 \
  - D
]

让我们逐一分析 8051 存储器系统的特点：

- A. 程序和数据两种类型的存储器同时存在： 这是 8051 的典型特点，它采用了*哈佛结构*，程序存储器和数据存储器有独立的地址空间和总线，可以同时访问。
- B. 芯片内外存储器同时存在： 8051 内部既有片内 ROM（程序存储器）和片内 RAM（数据存储器），也支持扩展外部 RAM 和 ROM。
- C. 扩展数据存储器与片内数据存储器存储空间重叠： 8051 的片内数据存储器地址范围是 00H-FFH，而外部数据存储器的地址可以从 `0000H-FFFFH`。当访问外部数据存储器时，地址范围可能会与片内数据存储器有重叠，但它们是通过不同的指令（如 `MOV @Ri` 用于片内，`MOVX @DPTR` 用于片外）来区分访问的，所以逻辑上不重叠。
- D. 扩展程序存储器与片内程序存储器存储空间重叠： 这是错误的。 8051 的程序存储器地址空间是 `0000H-FFFFH`。当外部程序存储器启用时，它会完全覆盖片内程序存储器的地址空间，而不是重叠。例如，如果 `PSEN` 引脚为低电平（表示访问外部程序存储器），则片内程序存储器将被禁用。

#rect[
  在存储器扩展编址中如下哪一种描述是错误的 () \
  A. 线选法不需要增加额外的电路 \
  B. 译码法适合大容量存储器扩展的编址 \
  C. 线选法会造成存储映像区重叠的编址 \
  D. 译码法会造成存储空间浪费 \
  - D
]

让我们分析一下存储器扩展编址的几种描述：
- A. 线选法不需要增加额外的电路： 正确。 线选法通常使用控制线的直接连接来选择存储器芯片，通常不需要额外的译码器电路，但它会占用大量的 I/O 口线，且适用于小容量扩展。
- B. 译码法适合大容量存储器扩展的编址： 正确。 译码法使用译码器来生成片选信号，可以更高效地利用地址线，从而支持更大容量的存储器扩展。
- C. 线选法会造成存储映像区重叠的编址： 正确。 在线选法中，由于没有进行完全地址译码，不同的地址组合可能会指向同一个存储芯片，导致存储器映像区重叠，这会限制可用地址空间。
- D. 译码法会造成存储空间浪费： 错误。 相比线选法，译码法可以更有效地利用地址线，减少了存储器映像区的重叠，从而更有效地利用存储空间，而非浪费。造成存储空间浪费的通常是不完全译码（一种简化译码法），而不是译码法本身固有的特性。

#rect[
  如在系统中只扩展一片 Intel 2732 （ 4K #sym.times 8 ）除应使用P0 口的 8 条口线外. 至少还应使用 P2 口的囗线（）
  - 4条
]

Intel 2732 是一种 4K #sym.times 8 位的 EPROM。
- 容量： $4K = 4 times 1024=4096$ 字节。
- 地址线需求： 要访问 $4096$ 个字节，需要 $2^12=4096$ 地址，所以需要 12 根地址线。
8051 微控制器使用 P0 口作为低 8 位地址线（A0-A7）和数据线的复用口。
因此，对于 12 根地址线：
- P0 口提供了 8 条线（`A0-A7`）。
- 剩下的 $12−8=4$ 条地址线（`A8-A11`）需要由 P2 口提供。
所以，至少还应使用 P2 口的 4 条口线。

#rect[
  在使用译码法同时扩展多片数据存储器芯片时，不能在各存储器芯片间并行连接的信号是（）
  - 地址译码输出信号
]
在使用译码法同时扩展多片数据存储器芯片时，地址译码输出信号不能在各存储器芯片间并行连接。

- 地址译码输出信号是用于选择特定存储器芯片的唯一信号（通常是片选信号 #overline("CS") 或 #overline("CE")）。每片存储器芯片必须有自己独立的片选信号，才能确保在任何给定时间只有一个芯片被选中进行读写操作。如果这些信号并行连接，那么同时会有多片芯片被选中，导致数据冲突和系统错误。
- 而其他信号，如地址线（CPU 发出的地址信息，告诉存储器要访问哪个位置）、数据线（用于传输数据）和读写控制信号（如 #overline("RD") 和 #overline("WR")，指示是读取还是写入操作），在扩展多片存储器时都是并行连接到所有存储器芯片的，它们构成共享的总线。

#rect[
  MCS-51存储器进行扩展时，如下哪种表达是准确的？ \
  A. P0和P2口分别作为高8位和低8位地址线 \
  B. P2和P0口分别作为高8位和低8位地址线 \
  C. P0可以作为8位数据线和高8位地址线 \
  D. P0可以作为8位数据线和低8位地址线 \
  - BD
]

- P0 口在扩展存储器时，是一个多功能复用口。它既作为低 8 位地址线（A0-A7），又作为8 位数据线（D0-D7）。在不同的时钟周期，通过 ALE (地址锁存使能) 信号来区分是地址信息还是数据信息。
- P2 口则主要用作高 8 位地址线（A8-A15）。

#rect[
  在下列信号中，不是给程序存储器扩展使用的是（）\
  A. /PSEN \
  B. /EA \
  C. ALE \
  D. /WR \
  - D
]

- `/PSEN` (Program Store Enable): 这是*程序存储器读选通信号*。当 8051 从外部程序存储器取指令或数据时，/PSEN 会变为低电平，用于使能外部 ROM 的输出。因此，它是程序存储器扩展必需的信号。
- `/EA` (External Access Enable): 这是*外部访问使能信号*。当 /EA 连接到低电平（接地）时，CPU 会从外部程序存储器启动并执行程序。如果 /EA 连接到高电平（VCC），CPU 会优先从片内 ROM 取指令。所以，/EA 是程序存储器扩展的关键配置信号。
- `ALE` (Address Latch Enable): 这是*地址锁存使能信号*。P0 口在不同时刻分时复用地址和数据。ALE 信号在 P0 口输出地址时有效，用于外部地址锁存器锁存低 8 位地址。无论是扩展程序存储器还是数据存储器，ALE 都是需要的。
- `/WR` (Write Enable): 这是*写使能信号*。/WR 信号用于外部数据存储器的写操作，表示要将数据写入外部 RAM。程序存储器（ROM 或 EPROM）通常是只读的，所以写入操作与它无关。因此，/WR 不是用于程序存储器扩展的信号。

#rect[
  在微控制器中，为实现数据的I/O传送可使用3种控制方式?
  - 无条件传送, 查询, 中断
]

在微控制器中，实现数据的 I/O 传送通常可以使用以下三种控制方式：

- *无条件传送* (Unconditional Transfer): 这是最简单的数据传送方式。CPU 不检查外设的状态，直接将数据发送给外设或从外设读取数据。这种方式适用于外设总是准备好接收或发送数据，或者对数据丢失不敏感的简单场景。
- *查询* (Polling): CPU 不断地循环检测外设的状态标志位，以确定外设是否准备好进行数据传送。当外设准备好时，CPU 才执行数据传送操作。这种方式的优点是简单，但缺点是 CPU 需要花费大量时间在等待上，效率较低。
- *中断* (Interrupt): 这是最高效的数据传送方式。CPU 在执行主程序时，外设在准备好数据时会向 CPU 发送中断请求。CPU 响应中断后，暂停当前主程序，跳转到中断服务程序中进行数据传送，完成后再返回主程序。这种方式大大提高了 CPU 的利用率。

#rect[
  一个I/O接口电路中只能有一个端口
  - 错
]

#rect[
  下列功能中不是由I/O接口实现的是（） \
  A. 速度协调 \
  B. 数据缓冲和锁存 \
  C. 信号（数据）转换 \
  D. 数据暂存 \
  - D
]

#rect[
  三态缓冲器的输出应具有三种状态，其中不包括
  - 低阻抗状态
]

#rect[
  在接口电路中的“端口”一定是一个（）
  A. 已赋值的寄存器
  B. 数据寄存器
  C. 可编址的寄存器
  D. 既可读又可写的寄存器
  - C
]
